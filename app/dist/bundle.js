/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/components/App.svelte":
/*!***********************************!*\
  !*** ./src/components/App.svelte ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var svelte__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte */ "./node_modules/svelte/index.mjs");
/* harmony import */ var svelte_transition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! svelte/transition */ "./node_modules/svelte/transition/index.mjs");
/* harmony import */ var store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! store */ "./src/store/index.js");
/* harmony import */ var _Button__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Button */ "./src/components/Button.svelte");
/* harmony import */ var _Prompts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Prompts */ "./src/components/Prompts.svelte");
/* harmony import */ var _Menu__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Menu */ "./src/components/Menu.svelte");
/* harmony import */ var _Integrations_Integration__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Integrations/Integration */ "./src/components/Integrations/Integration.svelte");
/* src/components/App.svelte generated by Svelte v3.31.2 */










function add_css() {
	var style = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("style");
	style.id = "svelte-1s1ac6b-style";
	style.textContent = "div.svelte-1s1ac6b{position:fixed;z-index:999;margin:50px;min-width:220px;font-family:-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen-Sans, Ubuntu, Cantarell, \"Helvetica Neue\", sans-serif}div.svelte-1s1ac6b .with-pointer-arrow::before{content:\"\";position:absolute;bottom:-6px;right:20px;left:auto;border-right:10px solid transparent;border-top:10px solid #FFFFFF;border-left:10px solid transparent;border-bottom:0px solid transparent}";
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(document.head, style);
}

// (51:0) {#if $showButton}
function create_if_block(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let div_transition;
	let current;
	let if_block0 = !/*$showIntegration*/ ctx[2] && create_if_block_4(ctx);
	let if_block1 = !/*$showMenu*/ ctx[3] && /*$showPrompts*/ ctx[4] && create_if_block_3(ctx);
	let if_block2 = /*$showMenu*/ ctx[3] && create_if_block_2(ctx);
	let if_block3 = /*$showIntegration*/ ctx[2] && create_if_block_1(ctx);

	return {
		c() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			if (if_block0) if_block0.c();
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			if (if_block1) if_block1.c();
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			if (if_block2) if_block2.c();
			t2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			if (if_block3) if_block3.c();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div, "style", /*style*/ ctx[0]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div, "class", "svelte-1s1ac6b");
		},
		m(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div, t0);
			if (if_block1) if_block1.m(div, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div, t1);
			if (if_block2) if_block2.m(div, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div, t2);
			if (if_block3) if_block3.m(div, null);
			current = true;
		},
		p(ctx, dirty) {
			if (!/*$showIntegration*/ ctx[2]) {
				if (if_block0) {
					if (dirty & /*$showIntegration*/ 4) {
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
			}

			if (!/*$showMenu*/ ctx[3] && /*$showPrompts*/ ctx[4]) {
				if (if_block1) {
					if (dirty & /*$showMenu, $showPrompts*/ 24) {
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_3(ctx);
					if_block1.c();
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block1, 1);
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
			}

			if (/*$showMenu*/ ctx[3]) {
				if (if_block2) {
					if (dirty & /*$showMenu*/ 8) {
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_2(ctx);
					if_block2.c();
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block2, 1);
					if_block2.m(div, t2);
				}
			} else if (if_block2) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
			}

			if (/*$showIntegration*/ ctx[2]) {
				if (if_block3) {
					if (dirty & /*$showIntegration*/ 4) {
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_1(ctx);
					if_block3.c();
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block3, 1);
					if_block3.m(div, null);
				}
			} else if (if_block3) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
			}

			if (!current || dirty & /*style*/ 1) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div, "style", /*style*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block3);

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_render_callback)(() => {
				if (!div_transition) div_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(div, svelte_transition__WEBPACK_IMPORTED_MODULE_2__.fly, { y: 100, duration: 500 }, true);
				div_transition.run(1);
			});

			current = true;
		},
		o(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block3);
			if (!div_transition) div_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(div, svelte_transition__WEBPACK_IMPORTED_MODULE_2__.fly, { y: 100, duration: 500 }, false);
			div_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (detaching && div_transition) div_transition.end();
		}
	};
}

// (53:8) {#if ! $showIntegration}
function create_if_block_4(ctx) {
	let button_1;
	let current;
	button_1 = new _Button__WEBPACK_IMPORTED_MODULE_4__.default({});

	return {
		c() {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(button_1.$$.fragment);
		},
		m(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(button_1, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(button_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(button_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(button_1, detaching);
		}
	};
}

// (57:8) {#if ! $showMenu && $showPrompts}
function create_if_block_3(ctx) {
	let prompts;
	let current;
	prompts = new _Prompts__WEBPACK_IMPORTED_MODULE_5__.default({});

	return {
		c() {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(prompts.$$.fragment);
		},
		m(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(prompts, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(prompts.$$.fragment, local);
			current = true;
		},
		o(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(prompts.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(prompts, detaching);
		}
	};
}

// (61:8) {#if $showMenu}
function create_if_block_2(ctx) {
	let menu;
	let current;
	menu = new _Menu__WEBPACK_IMPORTED_MODULE_6__.default({});

	return {
		c() {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(menu.$$.fragment);
		},
		m(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(menu, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(menu.$$.fragment, local);
			current = true;
		},
		o(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(menu.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(menu, detaching);
		}
	};
}

// (65:8) {#if $showIntegration}
function create_if_block_1(ctx) {
	let integration;
	let current;
	integration = new _Integrations_Integration__WEBPACK_IMPORTED_MODULE_7__.default({});

	return {
		c() {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(integration.$$.fragment);
		},
		m(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(integration, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(integration.$$.fragment, local);
			current = true;
		},
		o(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(integration.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(integration, detaching);
		}
	};
}

function create_fragment(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*$showButton*/ ctx[1] && create_if_block(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.empty)();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*$showButton*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*$showButton*/ 2) {
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block, 1, 1, () => {
					if_block = null;
				});

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
			}
		},
		i(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block);
			current = true;
		},
		o(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block);
			current = false;
		},
		d(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(if_block_anchor);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $button;
	let $showButton;
	let $showIntegration;
	let $showMenu;
	let $showPrompts;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, store__WEBPACK_IMPORTED_MODULE_3__.button, $$value => $$invalidate(5, $button = $$value));
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, store__WEBPACK_IMPORTED_MODULE_3__.showButton, $$value => $$invalidate(1, $showButton = $$value));
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, store__WEBPACK_IMPORTED_MODULE_3__.showIntegration, $$value => $$invalidate(2, $showIntegration = $$value));
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, store__WEBPACK_IMPORTED_MODULE_3__.showMenu, $$value => $$invalidate(3, $showMenu = $$value));
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, store__WEBPACK_IMPORTED_MODULE_3__.showPrompts, $$value => $$invalidate(4, $showPrompts = $$value));
	let style = ``;

	(0,svelte__WEBPACK_IMPORTED_MODULE_1__.onMount)(() => {
		store__WEBPACK_IMPORTED_MODULE_3__.showButton.set(true);

		setTimeout(
			() => {
				
			},
			3000
		); // showPrompts.set(true)
		// showPrompts.set(true)
	});

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$button, style*/ 33) {
			// Position style
			$: ["top", "bottom", "left", "right"].forEach(e => {
				if ($button.position.includes(e)) {
					$$invalidate(0, style += e + ": 0;");
				}
			});
		}
	};

	return [style, $showButton, $showIntegration, $showMenu, $showPrompts, $button];
}

class App extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1s1ac6b-style")) add_css();
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {});
	}
}


if (false) {}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (App);


/***/ }),

/***/ "./src/components/Button.svelte":
/*!**************************************!*\
  !*** ./src/components/Button.svelte ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var svelte_transition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte/transition */ "./node_modules/svelte/transition/index.mjs");
/* harmony import */ var store__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! store */ "./src/store/index.js");
/* src/components/Button.svelte generated by Svelte v3.31.2 */





function add_css() {
	var style = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("style");
	style.id = "svelte-1dx1n1i-style";
	style.textContent = "div.svelte-1dx1n1i.svelte-1dx1n1i{font-size:15px;border-radius:5px;overflow:hidden;cursor:pointer;float:right;height:42px;line-height:42px;overflow:hidden;box-shadow:rgba(0, 0, 0, 0.1) 0px 12px 24px 0px}div.svelte-1dx1n1i i.svelte-1dx1n1i{background:rgba(255, 255, 255, 0.125);float:right;height:inherit;display:flex;align-items:center;justify-content:center;width:48px;overflow:hidden}div.svelte-1dx1n1i i div.svelte-1dx1n1i{display:flex}div.svelte-1dx1n1i i.svelte-1dx1n1i svg{width:20px;fill:currentColor}div.svelte-1dx1n1i span.svelte-1dx1n1i{line-height:inherit;padding:0px 20px;float:right}div[data-size=small].svelte-1dx1n1i.svelte-1dx1n1i{font-size:14px;height:40px;line-height:40px}div[data-size=small].svelte-1dx1n1i i.svelte-1dx1n1i{width:45px}div[data-size=small].svelte-1dx1n1i i.svelte-1dx1n1i svg{width:18px}div[data-size=large].svelte-1dx1n1i.svelte-1dx1n1i{font-size:15px;height:45px;line-height:45px}div[data-size=large].svelte-1dx1n1i i.svelte-1dx1n1i{width:50px}div[data-size=large].svelte-1dx1n1i i.svelte-1dx1n1i svg{width:24px}";
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(document.head, style);
}

// (84:12) {:else}
function create_else_block(ctx) {
	let div;
	let raw_value = /*$button*/ ctx[0].icon + "";
	let div_intro;

	return {
		c() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div, "class", "svelte-1dx1n1i");
		},
		m(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, div, anchor);
			div.innerHTML = raw_value;
		},
		p(ctx, dirty) {
			if (dirty & /*$button*/ 1 && raw_value !== (raw_value = /*$button*/ ctx[0].icon + "")) div.innerHTML = raw_value;;
		},
		i(local) {
			if (!div_intro) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_render_callback)(() => {
					div_intro = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_in_transition)(div, svelte_transition__WEBPACK_IMPORTED_MODULE_1__.fly, { x: 20 });
					div_intro.start();
				});
			}
		},
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		d(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(div);
		}
	};
}

// (76:12) {#if $showMenu || $showIntegration}
function create_if_block_1(ctx) {
	let div;
	let div_intro;

	return {
		c() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			div.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10zm0-11.414L9.172 7.757 7.757 9.172 10.586 12l-2.829 2.828 1.415 1.415L12 13.414l2.828 2.829 1.415-1.415L13.414 12l2.829-2.828-1.415-1.415L12 10.586z"></path></svg>`;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div, "class", "svelte-1dx1n1i");
		},
		m(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, div, anchor);
		},
		p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		i(local) {
			if (!div_intro) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_render_callback)(() => {
					div_intro = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_in_transition)(div, svelte_transition__WEBPACK_IMPORTED_MODULE_1__.fly, { x: 20 });
					div_intro.start();
				});
			}
		},
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		d(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(div);
		}
	};
}

// (91:4) {#if $button.text && ! $showMenu && ! $showIntegration}
function create_if_block(ctx) {
	let span;
	let t_value = /*$button*/ ctx[0].text + "";
	let t;

	return {
		c() {
			span = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");
			t = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t_value);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(span, "class", "svelte-1dx1n1i");
		},
		m(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, span, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*$button*/ 1 && t_value !== (t_value = /*$button*/ ctx[0].text + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data)(t, t_value);
		},
		d(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(span);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let i;
	let t;
	let div_data_size_value;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*$showMenu*/ ctx[1] || /*$showIntegration*/ ctx[2]) return create_if_block_1;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block0 = current_block_type(ctx);
	let if_block1 = /*$button*/ ctx[0].text && !/*$showMenu*/ ctx[1] && !/*$showIntegration*/ ctx[2] && create_if_block(ctx);

	return {
		c() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			i = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("i");
			if_block0.c();
			t = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			if (if_block1) if_block1.c();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(i, "class", "svelte-1dx1n1i");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div, "data-size", div_data_size_value = /*$button*/ ctx[0].size);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div, "style", /*style*/ ctx[3]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div, "class", "svelte-1dx1n1i");
		},
		m(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, div, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div, i);
			if_block0.m(i, null);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div, t);
			if (if_block1) if_block1.m(div, null);

			if (!mounted) {
				dispose = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen)(div, "click", /*click*/ ctx[4]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0, 1);
					if_block0.m(i, null);
				}
			}

			if (/*$button*/ ctx[0].text && !/*$showMenu*/ ctx[1] && !/*$showIntegration*/ ctx[2]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty & /*$button*/ 1 && div_data_size_value !== (div_data_size_value = /*$button*/ ctx[0].size)) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div, "data-size", div_data_size_value);
			}
		},
		i(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block0);
		},
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		d(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(div);
			if_block0.d();
			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $button;
	let $showMenu;
	let $showIntegration;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, store__WEBPACK_IMPORTED_MODULE_2__.button, $$value => $$invalidate(0, $button = $$value));
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, store__WEBPACK_IMPORTED_MODULE_2__.showMenu, $$value => $$invalidate(1, $showMenu = $$value));
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, store__WEBPACK_IMPORTED_MODULE_2__.showIntegration, $$value => $$invalidate(2, $showIntegration = $$value));

	let style = `
        color: ${$button.color};
        background-color: ${$button.bg};
    `;

	let click = () => {
		store__WEBPACK_IMPORTED_MODULE_2__.showMenu.set(!$showMenu);
		store__WEBPACK_IMPORTED_MODULE_2__.showPrompts.set(false);
	};

	return [$button, $showMenu, $showIntegration, style, click];
}

class Button extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1dx1n1i-style")) add_css();
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {});
	}
}


if (false) {}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Button);


/***/ }),

/***/ "./src/components/Integrations/Integration.svelte":
/*!********************************************************!*\
  !*** ./src/components/Integrations/Integration.svelte ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var svelte_transition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte/transition */ "./node_modules/svelte/transition/index.mjs");
/* harmony import */ var store__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! store */ "./src/store/index.js");
/* harmony import */ var _WhatsApp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WhatsApp */ "./src/components/Integrations/WhatsApp.svelte");
/* harmony import */ var _Messenger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Messenger */ "./src/components/Integrations/Messenger.svelte");
/* src/components/Integrations/Integration.svelte generated by Svelte v3.31.2 */







function add_css() {
	var style = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("style");
	style.id = "svelte-vmz7gn-style";
	style.textContent = "div.svelte-vmz7gn{box-shadow:rgba(0, 0, 0, 0.1) 0px 12px 24px 0px;background:#fff;position:absolute;bottom:0px;right:0;border-radius:10px;margin:0}";
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(document.head, style);
}

function create_fragment(ctx) {
	let div;
	let switch_instance;
	let div_transition;
	let current;
	var switch_value = /*types*/ ctx[1][/*$integration*/ ctx[0].type];

	function switch_props(ctx) {
		return {
			props: { options: /*$integration*/ ctx[0] }
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		c() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			if (switch_instance) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(switch_instance.$$.fragment);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div, "class", "svelte-vmz7gn");
		},
		m(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, div, anchor);

			if (switch_instance) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(switch_instance, div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			const switch_instance_changes = {};
			if (dirty & /*$integration*/ 1) switch_instance_changes.options = /*$integration*/ ctx[0];

			if (switch_value !== (switch_value = /*types*/ ctx[1][/*$integration*/ ctx[0].type])) {
				if (switch_instance) {
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();
					const old_component = switch_instance;

					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(old_component.$$.fragment, 1, 0, () => {
						(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(old_component, 1);
					});

					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(switch_instance.$$.fragment);
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(switch_instance.$$.fragment, 1);
					(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(switch_instance, div, null);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(switch_instance.$$.fragment, local);

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_render_callback)(() => {
				if (!div_transition) div_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(div, svelte_transition__WEBPACK_IMPORTED_MODULE_1__.fly, { x: 40 }, true);
				div_transition.run(1);
			});

			current = true;
		},
		o(local) {
			if (switch_instance) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(switch_instance.$$.fragment, local);
			if (!div_transition) div_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(div, svelte_transition__WEBPACK_IMPORTED_MODULE_1__.fly, { x: 40 }, false);
			div_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(div);
			if (switch_instance) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(switch_instance);
			if (detaching && div_transition) div_transition.end();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $integration;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, store__WEBPACK_IMPORTED_MODULE_2__.integration, $$value => $$invalidate(0, $integration = $$value));
	let types = { whatsapp: _WhatsApp__WEBPACK_IMPORTED_MODULE_3__.default, messenger: _Messenger__WEBPACK_IMPORTED_MODULE_4__.default };
	return [$integration, types];
}

class Integration extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-vmz7gn-style")) add_css();
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {});
	}
}


if (false) {}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Integration);


/***/ }),

/***/ "./src/components/Integrations/Messenger.svelte":
/*!******************************************************!*\
  !*** ./src/components/Integrations/Messenger.svelte ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* src/components/Integrations/Messenger.svelte generated by Svelte v3.31.2 */


function add_css() {
	var style = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("style");
	style.id = "svelte-zwn9af-style";
	style.textContent = "div.svelte-zwn9af.svelte-zwn9af{width:325px;border-radius:10px;overflow:hidden}div.svelte-zwn9af header.svelte-zwn9af{padding:25px 20px;overflow:hidden;display:flex;align-items:center;background:#fff;border-bottom:1px solid #f4f4f4}div.svelte-zwn9af header figure.svelte-zwn9af{position:relative;width:52px;height:52px;display:flex;align-items:center;justify-content:center;color:#fff;border-radius:50px;float:left;margin-right:15px}div.svelte-zwn9af header figure img.svelte-zwn9af{width:100%;height:auto;border-radius:50px}div.svelte-zwn9af header figure.svelte-zwn9af::before{content:\"\";bottom:0px;right:0px;width:12px;height:12px;box-sizing:border-box;background-color:#4ad504;display:block;position:absolute;z-index:1;border-radius:50%;border:2px solid white}div.svelte-zwn9af header aside.svelte-zwn9af{width:calc(100% - 65px);float:left;margin:0;padding:0}div.svelte-zwn9af header aside h4.svelte-zwn9af{float:left;margin:0px;padding:0px;letter-spacing:0.1px;font-size:16px;font-weight:700;line-height:20px;color:#111;width:100%}div.svelte-zwn9af header aside span.svelte-zwn9af{float:left;color:#333;font-weight:normal;font-size:13px;line-height:18px;margin-top:5px}div.svelte-zwn9af article.svelte-zwn9af{padding:30px 20px;position:relative;overflow:auto}div.svelte-zwn9af article small.svelte-zwn9af{font-size:10px;line-height:14px;color:#d4d4d4;width:100%;text-align:center;padding-top:0px;float:right;letter-spacing:0.3px;margin-top:-14px;margin-bottom:16px}div.svelte-zwn9af article img.svelte-zwn9af{width:30px;height:auto;border-radius:50px;float:left;margin-right:10px}div.svelte-zwn9af article aside.svelte-zwn9af{padding:8px 12px;background:#f4f4f4;border-radius:8px;max-width:225px;float:left;position:relative}div.svelte-zwn9af article aside p.svelte-zwn9af{font-size:14px;line-height:19px;margin:0;color:#000000;float:left;width:100%}div.svelte-zwn9af footer.svelte-zwn9af{padding:20px;overflow:hidden;background:#fff;display:block}div.svelte-zwn9af footer a.svelte-zwn9af{text-decoration:none;font-size:15px;color:#fff;width:100%;float:left;text-align:center;font-weight:700;border-radius:8px;display:flex;height:36px;justify-content:center;align-items:center}div.svelte-zwn9af footer a svg.svelte-zwn9af{width:18px;margin-right:6px;fill:currentColor}";
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(document.head, style);
}

function create_fragment(ctx) {
	let div;
	let header;
	let figure;
	let img0;
	let img0_src_value;
	let img0_alt_value;
	let t0;
	let aside0;
	let h4;
	let t1_value = /*options*/ ctx[0].user_name + "";
	let t1;
	let t2;
	let span;
	let t3_value = /*options*/ ctx[0].caption + "";
	let t3;
	let t4;
	let article;
	let small;
	let t6;
	let img1;
	let img1_src_value;
	let img1_alt_value;
	let t7;
	let aside1;
	let p;
	let raw_value = /*options*/ ctx[0].welcome_message + "";
	let t8;
	let footer;
	let a;
	let svg;
	let g;
	let path0;
	let path1;
	let t9;
	let a_href_value;

	return {
		c() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			header = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("header");
			figure = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("figure");
			img0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("img");
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			aside0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("aside");
			h4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("h4");
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t1_value);
			t2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			span = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");
			t3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t3_value);
			t4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			article = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("article");
			small = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("small");
			small.textContent = `${/*time*/ ctx[1]}`;
			t6 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			img1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("img");
			t7 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			aside1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("aside");
			p = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("p");
			t8 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			footer = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("footer");
			a = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("a");
			svg = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("svg");
			g = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("g");
			path0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			path1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.svg_element)("path");
			t9 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)("\n            \n            Start Chat");
			if (img0.src !== (img0_src_value = /*options*/ ctx[0].avatar)) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(img0, "src", img0_src_value);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(img0, "alt", img0_alt_value = /*options*/ ctx[0].user_name);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(img0, "class", "svelte-zwn9af");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(figure, "class", "svelte-zwn9af");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(h4, "class", "svelte-zwn9af");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(span, "class", "svelte-zwn9af");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(aside0, "class", "svelte-zwn9af");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(header, "class", "svelte-zwn9af");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(small, "class", "svelte-zwn9af");
			if (img1.src !== (img1_src_value = /*options*/ ctx[0].avatar)) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(img1, "src", img1_src_value);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(img1, "alt", img1_alt_value = /*options*/ ctx[0].user_name);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(img1, "class", "svelte-zwn9af");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(p, "class", "svelte-zwn9af");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(aside1, "class", "svelte-zwn9af");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(article, "class", "svelte-zwn9af");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(path0, "fill", "none");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(path0, "d", "M0 0h24v24H0z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(path1, "fill-rule", "nonzero");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(path1, "d", "M12 2c5.634 0 10 4.127 10 9.7 0 5.573-4.366 9.7-10 9.7a10.894 10.894 0 0 1-2.895-.384.8.8 0 0 0-.534.039l-1.984.876a.8.8 0 0 1-1.123-.707l-.055-1.78a.797.797 0 0 0-.268-.57C3.195 17.135 2 14.617 2 11.7 2 6.127 6.367 2 12 2zM5.995 14.537c-.282.447.268.951.689.631l3.155-2.394a.6.6 0 0 1 .723 0l2.337 1.75a1.5 1.5 0 0 0 2.169-.4l2.937-4.66c.282-.448-.268-.952-.689-.633l-3.155 2.396a.6.6 0 0 1-.723 0l-2.337-1.75a1.5 1.5 0 0 0-2.169.4l-2.937 4.66z");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(svg, "xmlns", "http://www.w3.org/2000/svg");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(svg, "viewBox", "0 0 24 24");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(svg, "class", "svelte-zwn9af");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(a, "href", a_href_value = /*options*/ ctx[0].messenger_url);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(a, "target", "_blank");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(a, "background-color", /*options*/ ctx[0].color);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(a, "class", "svelte-zwn9af");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(footer, "class", "svelte-zwn9af");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div, "class", "svelte-zwn9af");
		},
		m(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, div, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div, header);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(header, figure);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(figure, img0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(header, t0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(header, aside0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(aside0, h4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(h4, t1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(aside0, t2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(aside0, span);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(span, t3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div, t4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div, article);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(article, small);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(article, t6);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(article, img1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(article, t7);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(article, aside1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(aside1, p);
			p.innerHTML = raw_value;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div, t8);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div, footer);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(footer, a);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(a, svg);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(svg, g);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(g, path0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(g, path1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(a, t9);
		},
		p(ctx, [dirty]) {
			if (dirty & /*options*/ 1 && img0.src !== (img0_src_value = /*options*/ ctx[0].avatar)) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(img0, "src", img0_src_value);
			}

			if (dirty & /*options*/ 1 && img0_alt_value !== (img0_alt_value = /*options*/ ctx[0].user_name)) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(img0, "alt", img0_alt_value);
			}

			if (dirty & /*options*/ 1 && t1_value !== (t1_value = /*options*/ ctx[0].user_name + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data)(t1, t1_value);
			if (dirty & /*options*/ 1 && t3_value !== (t3_value = /*options*/ ctx[0].caption + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data)(t3, t3_value);

			if (dirty & /*options*/ 1 && img1.src !== (img1_src_value = /*options*/ ctx[0].avatar)) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(img1, "src", img1_src_value);
			}

			if (dirty & /*options*/ 1 && img1_alt_value !== (img1_alt_value = /*options*/ ctx[0].user_name)) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(img1, "alt", img1_alt_value);
			}

			if (dirty & /*options*/ 1 && raw_value !== (raw_value = /*options*/ ctx[0].welcome_message + "")) p.innerHTML = raw_value;;

			if (dirty & /*options*/ 1 && a_href_value !== (a_href_value = /*options*/ ctx[0].messenger_url)) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(a, "href", a_href_value);
			}

			if (dirty & /*options*/ 1) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(a, "background-color", /*options*/ ctx[0].color);
			}
		},
		i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		d(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(div);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { options } = $$props;
	let today = new Date();
	let time = today.getHours() + ":" + today.getMinutes();

	options.messenger_url = options.messenger_url.indexOf("://") === -1
	? "http://" + options.messenger_url
	: options.messenger_url;

	$$self.$$set = $$props => {
		if ("options" in $$props) $$invalidate(0, options = $$props.options);
	};

	return [options, time];
}

class Messenger extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-zwn9af-style")) add_css();
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, { options: 0 });
	}
}


if (false) {}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Messenger);


/***/ }),

/***/ "./src/components/Integrations/WhatsApp.svelte":
/*!*****************************************************!*\
  !*** ./src/components/Integrations/WhatsApp.svelte ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* src/components/Integrations/WhatsApp.svelte generated by Svelte v3.31.2 */


function add_css() {
	var style = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("style");
	style.id = "svelte-8fyqg1-style";
	style.textContent = "div.svelte-8fyqg1.svelte-8fyqg1{width:325px;border-radius:10px;overflow:hidden}div.svelte-8fyqg1 header.svelte-8fyqg1{padding:25px 20px;overflow:hidden;display:flex;align-items:center;background:#fff}div.svelte-8fyqg1 header figure.svelte-8fyqg1{position:relative;width:52px;height:52px;display:flex;align-items:center;justify-content:center;color:#fff;border-radius:50px;float:left;margin-right:15px}div.svelte-8fyqg1 header figure img.svelte-8fyqg1{width:100%;height:auto;border-radius:50px}div.svelte-8fyqg1 header figure.svelte-8fyqg1::before{content:\"\";bottom:0px;right:0px;width:12px;height:12px;box-sizing:border-box;background-color:#4ad504;display:block;position:absolute;z-index:1;border-radius:50%;border:2px solid white}div.svelte-8fyqg1 header aside.svelte-8fyqg1{width:calc(100% - 65px);float:left;margin:0;padding:0}div.svelte-8fyqg1 header aside h4.svelte-8fyqg1{float:left;margin:0px;padding:0px;letter-spacing:0.1px;font-size:16px;font-weight:700;line-height:20px;color:#111;width:100%}div.svelte-8fyqg1 header aside span.svelte-8fyqg1{float:left;color:#333;font-weight:normal;font-size:13px;line-height:18px;margin-top:5px}div.svelte-8fyqg1 article.svelte-8fyqg1{padding:25px 20px;background-color:#e6ddd4;position:relative;overflow:auto}div.svelte-8fyqg1 article.svelte-8fyqg1::before{display:block;position:absolute;content:\"\";left:0px;top:0px;height:100%;width:100%;z-index:0;opacity:0.08;background-image:url(https://elfsight.com/assets/chats/patterns/whatsapp.png)}div.svelte-8fyqg1 article aside.svelte-8fyqg1{padding:7px 14px 6px;background:#fff;box-shadow:rgba(0, 0, 0, 0.13) 0px 1px 0.5px;border-radius:0px 8px 8px;max-width:225px;float:left;position:relative}div.svelte-8fyqg1 article aside.svelte-8fyqg1::before{position:absolute;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAmCAMAAADp2asXAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAACQUExURUxpccPDw9ra2m9vbwAAAAAAADExMf///wAAABoaGk9PT7q6uqurqwsLCycnJz4+PtDQ0JycnIyMjPf3915eXvz8/E9PT/39/RMTE4CAgAAAAJqamv////////r6+u/v7yUlJeXl5f///5ycnOXl5XNzc/Hx8f///xUVFf///+zs7P///+bm5gAAAM7Ozv///2fVensAAAAvdFJOUwCow1cBCCnqAhNAnY0WIDW2f2/hSeo99g1lBYT87vDXG8/6d8oL4sgM5szrkgl660OiZwAAAHRJREFUKM/ty7cSggAABNFVUQFzwizmjPz/39k4YuFWtm55bw7eHR6ny63+alnswT3/rIDzUSC7CrAziPYCJCsB+gbVkgDtVIDh+DsE9OTBpCtAbSBAZSEQNgWIygJ0RgJMDWYNAdYbAeKtAHODlkHIv997AkLqIVOXVU84AAAAAElFTkSuQmCC);background-position:50% 50%;background-repeat:no-repeat;background-size:contain;content:\"\";top:0px;left:-12px;width:12px;height:19px}div.svelte-8fyqg1 article aside span.svelte-8fyqg1{color:#999;font-size:13px;margin-bottom:10px;float:left;width:100%;font-weight:500}div.svelte-8fyqg1 article aside p.svelte-8fyqg1{font-size:14px;line-height:19px;margin:0;color:#000000;float:left;width:100%}div.svelte-8fyqg1 article aside small.svelte-8fyqg1{font-size:12px;line-height:16px;color:#999;width:100%;text-align:right;padding-top:0px;float:right;margin-right:-4px;margin-bottom:0px}div.svelte-8fyqg1 footer.svelte-8fyqg1{padding:20px;overflow:hidden;background:#fff;display:block}div.svelte-8fyqg1 footer a.svelte-8fyqg1{text-decoration:none;font-size:15px;color:#fff;background:#4fce5d;padding:8px 14px;width:100%;float:left;text-align:center;font-weight:bold;border-radius:50px}";
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(document.head, style);
}

function create_fragment(ctx) {
	let div;
	let header;
	let figure;
	let img;
	let img_src_value;
	let img_alt_value;
	let t0;
	let aside0;
	let h4;
	let t1_value = /*options*/ ctx[0].user_name + "";
	let t1;
	let t2;
	let span0;
	let t3_value = /*options*/ ctx[0].caption + "";
	let t3;
	let t4;
	let article;
	let aside1;
	let span1;
	let t5_value = /*options*/ ctx[0].user_name + "";
	let t5;
	let t6;
	let p;
	let raw_value = /*options*/ ctx[0].welcome_message + "";
	let t7;
	let small;
	let t9;
	let footer;
	let a;
	let t10;
	let a_href_value;

	return {
		c() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			header = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("header");
			figure = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("figure");
			img = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("img");
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			aside0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("aside");
			h4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("h4");
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t1_value);
			t2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			span0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");
			t3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t3_value);
			t4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			article = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("article");
			aside1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("aside");
			span1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");
			t5 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t5_value);
			t6 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			p = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("p");
			t7 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			small = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("small");
			small.textContent = `${/*time*/ ctx[1]}`;
			t9 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			footer = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("footer");
			a = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("a");
			t10 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)("Start Chat");
			if (img.src !== (img_src_value = /*options*/ ctx[0].avatar)) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(img, "src", img_src_value);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(img, "alt", img_alt_value = /*options*/ ctx[0].user_name);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(img, "class", "svelte-8fyqg1");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(figure, "class", "svelte-8fyqg1");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(h4, "class", "svelte-8fyqg1");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(span0, "class", "svelte-8fyqg1");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(aside0, "class", "svelte-8fyqg1");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(header, "class", "svelte-8fyqg1");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(span1, "class", "svelte-8fyqg1");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(p, "class", "svelte-8fyqg1");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(small, "class", "svelte-8fyqg1");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(aside1, "class", "svelte-8fyqg1");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(article, "class", "svelte-8fyqg1");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(a, "href", a_href_value = "https://api.whatsapp.com/send?phone=" + /*options*/ ctx[0].phone);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(a, "target", "_blank");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(a, "background-color", /*options*/ ctx[0].color);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(a, "class", "svelte-8fyqg1");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(footer, "class", "svelte-8fyqg1");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div, "class", "svelte-8fyqg1");
		},
		m(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, div, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div, header);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(header, figure);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(figure, img);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(header, t0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(header, aside0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(aside0, h4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(h4, t1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(aside0, t2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(aside0, span0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(span0, t3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div, t4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div, article);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(article, aside1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(aside1, span1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(span1, t5);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(aside1, t6);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(aside1, p);
			p.innerHTML = raw_value;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(aside1, t7);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(aside1, small);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div, t9);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(div, footer);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(footer, a);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(a, t10);
		},
		p(ctx, [dirty]) {
			if (dirty & /*options*/ 1 && img.src !== (img_src_value = /*options*/ ctx[0].avatar)) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(img, "src", img_src_value);
			}

			if (dirty & /*options*/ 1 && img_alt_value !== (img_alt_value = /*options*/ ctx[0].user_name)) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(img, "alt", img_alt_value);
			}

			if (dirty & /*options*/ 1 && t1_value !== (t1_value = /*options*/ ctx[0].user_name + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data)(t1, t1_value);
			if (dirty & /*options*/ 1 && t3_value !== (t3_value = /*options*/ ctx[0].caption + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data)(t3, t3_value);
			if (dirty & /*options*/ 1 && t5_value !== (t5_value = /*options*/ ctx[0].user_name + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data)(t5, t5_value);
			if (dirty & /*options*/ 1 && raw_value !== (raw_value = /*options*/ ctx[0].welcome_message + "")) p.innerHTML = raw_value;;

			if (dirty & /*options*/ 1 && a_href_value !== (a_href_value = "https://api.whatsapp.com/send?phone=" + /*options*/ ctx[0].phone)) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(a, "href", a_href_value);
			}

			if (dirty & /*options*/ 1) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(a, "background-color", /*options*/ ctx[0].color);
			}
		},
		i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		d(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(div);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { options } = $$props;
	let today = new Date();
	let time = today.getHours() + ":" + today.getMinutes();

	$$self.$$set = $$props => {
		if ("options" in $$props) $$invalidate(0, options = $$props.options);
	};

	return [options, time];
}

class WhatsApp extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-8fyqg1-style")) add_css();
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, { options: 0 });
	}
}


if (false) {}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WhatsApp);


/***/ }),

/***/ "./src/components/Loader.svelte":
/*!**************************************!*\
  !*** ./src/components/Loader.svelte ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* src/components/Loader.svelte generated by Svelte v3.31.2 */


function add_css() {
	var style = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("style");
	style.id = "svelte-1yh32b8-style";
	style.textContent = "div.svelte-1yh32b8{width:5px;height:5px;border-radius:50%;box-shadow:0 10px 0 var(--loader-color);position:relative;animation:svelte-1yh32b8-loader-uycyrf1 0.5s ease-in-out alternate infinite;animation-delay:0.2s;top:-10px}div.svelte-1yh32b8::after,div.svelte-1yh32b8::before{content:\"\";position:absolute;width:5px;height:5px;border-radius:50%;box-shadow:0 10px 0 var(--loader-color);animation:svelte-1yh32b8-loader-uycyrf1 0.5s cubic-bezier(0.42, 0, 0.35, 0.89) alternate infinite}div.svelte-1yh32b8::before{left:-8px;animation-delay:0.3s}div.svelte-1yh32b8::after{right:-8px;animation-delay:0.1s}@keyframes svelte-1yh32b8-loader-uycyrf1{0%{box-shadow:0 10px 0 var(--loader-color)}100%{box-shadow:0 5px 0 var(--loader-color)}}";
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(document.head, style);
}

function create_fragment(ctx) {
	let div;

	return {
		c() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div, "style", /*style*/ ctx[0]);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div, "class", "svelte-1yh32b8");
		},
		m(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, div, anchor);
		},
		p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		d(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(div);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { color = "currentColor" } = $$props;
	let { size = 56 } = $$props;
	let { gap = 12 } = $$props;
	let { duration = 1 } = $$props;

	let style = `
		--loader-size: ${size}px;
		--loader-color: ${color};
		--loader-animation-duration: ${duration}s;
		--loader-gap: ${gap}px;
	`;

	$$self.$$set = $$props => {
		if ("color" in $$props) $$invalidate(1, color = $$props.color);
		if ("size" in $$props) $$invalidate(2, size = $$props.size);
		if ("gap" in $$props) $$invalidate(3, gap = $$props.gap);
		if ("duration" in $$props) $$invalidate(4, duration = $$props.duration);
	};

	return [style, color, size, gap, duration];
}

class Loader extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1yh32b8-style")) add_css();
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, { color: 1, size: 2, gap: 3, duration: 4 });
	}
}


if (false) {}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Loader);


/***/ }),

/***/ "./src/components/Menu.svelte":
/*!************************************!*\
  !*** ./src/components/Menu.svelte ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var svelte_transition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte/transition */ "./node_modules/svelte/transition/index.mjs");
/* harmony import */ var store__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! store */ "./src/store/index.js");
/* src/components/Menu.svelte generated by Svelte v3.31.2 */





function add_css() {
	var style = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("style");
	style.id = "svelte-n6anyd-style";
	style.textContent = "ul.svelte-n6anyd.svelte-n6anyd{box-shadow:rgba(0, 0, 0, 0.1) 0px 12px 24px 0px;padding:12px 0px;width:285px;background:#fff;position:absolute;bottom:75px;right:0;border-radius:5px;margin:0;list-style:none}ul.svelte-n6anyd li.svelte-n6anyd{float:left;width:100%;margin:0;padding:8px 16px;cursor:pointer}ul.svelte-n6anyd li.svelte-n6anyd:hover{background:#f1f1f1}ul.svelte-n6anyd li i.svelte-n6anyd{width:42px;height:42px;display:flex;align-items:center;justify-content:center;color:#fff;border-radius:50px;float:left;margin-right:14px}ul.svelte-n6anyd li i.svelte-n6anyd svg{width:24px;fill:currentColor}ul.svelte-n6anyd li h4.svelte-n6anyd{float:left;margin:0px;padding:0px;width:calc(100% - 60px);font-size:14px;font-weight:400;margin-top:1px;margin-bottom:3px;color:#111}ul.svelte-n6anyd li span.svelte-n6anyd{width:calc(100% - 60px);font-size:13px;float:left;color:#999999;font-weight:normal}";
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(document.head, style);
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[3] = list[i];
	return child_ctx;
}

// (77:4) {#each  $menu.items as item}
function create_each_block(ctx) {
	let li;
	let i;
	let raw_value = /*item*/ ctx[3].icon + "";
	let t0;
	let h4;
	let t1_value = /*item*/ ctx[3].title + "";
	let t1;
	let t2;
	let span;
	let t3_value = /*item*/ ctx[3].subtitle + "";
	let t3;
	let t4;
	let mounted;
	let dispose;

	function click_handler() {
		return /*click_handler*/ ctx[2](/*item*/ ctx[3]);
	}

	return {
		c() {
			li = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("li");
			i = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("i");
			t0 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			h4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("h4");
			t1 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t1_value);
			t2 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			span = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");
			t3 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(t3_value);
			t4 = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.space)();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(i, "background", /*item*/ ctx[3].color);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(i, "class", "svelte-n6anyd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(h4, "class", "svelte-n6anyd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(span, "class", "svelte-n6anyd");
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(li, "class", "svelte-n6anyd");
		},
		m(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, li, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(li, i);
			i.innerHTML = raw_value;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(li, t0);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(li, h4);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(h4, t1);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(li, t2);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(li, span);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(span, t3);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(li, t4);

			if (!mounted) {
				dispose = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.listen)(li, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*$menu*/ 1 && raw_value !== (raw_value = /*item*/ ctx[3].icon + "")) i.innerHTML = raw_value;;

			if (dirty & /*$menu*/ 1) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_style)(i, "background", /*item*/ ctx[3].color);
			}

			if (dirty & /*$menu*/ 1 && t1_value !== (t1_value = /*item*/ ctx[3].title + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data)(t1, t1_value);
			if (dirty & /*$menu*/ 1 && t3_value !== (t3_value = /*item*/ ctx[3].subtitle + "")) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data)(t3, t3_value);
		},
		d(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(li);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment(ctx) {
	let ul;
	let ul_transition;
	let current;
	let each_value = /*$menu*/ ctx[0].items;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			ul = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(ul, "class", "svelte-n6anyd");
		},
		m(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*click, $menu*/ 3) {
				each_value = /*$menu*/ ctx[0].items;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i(local) {
			if (current) return;

			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_render_callback)(() => {
				if (!ul_transition) ul_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(ul, svelte_transition__WEBPACK_IMPORTED_MODULE_1__.fly, { x: 40 }, true);
				ul_transition.run(1);
			});

			current = true;
		},
		o(local) {
			if (!ul_transition) ul_transition = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_bidirectional_transition)(ul, svelte_transition__WEBPACK_IMPORTED_MODULE_1__.fly, { x: 40 }, false);
			ul_transition.run(0);
			current = false;
		},
		d(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(ul);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_each)(each_blocks, detaching);
			if (detaching && ul_transition) ul_transition.end();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $menu;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, store__WEBPACK_IMPORTED_MODULE_2__.menu, $$value => $$invalidate(0, $menu = $$value));

	let click = item => {
		if (item.type == "link") {
			item.url = item.url.indexOf("://") === -1
			? "http://" + item.url
			: item.url;

			window.open(item.url, "_blank");
		} else {
			store__WEBPACK_IMPORTED_MODULE_2__.showMenu.set(false);
			store__WEBPACK_IMPORTED_MODULE_2__.showIntegration.set(true);
			store__WEBPACK_IMPORTED_MODULE_2__.integration.set(item);
		}
	};

	const click_handler = item => {
		click(item);
	};

	return [$menu, click, click_handler];
}

class Menu extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-n6anyd-style")) add_css();
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {});
	}
}


if (false) {}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Menu);


/***/ }),

/***/ "./src/components/Prompts.svelte":
/*!***************************************!*\
  !*** ./src/components/Prompts.svelte ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/internal */ "./node_modules/svelte/internal/index.mjs");
/* harmony import */ var svelte_transition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svelte/transition */ "./node_modules/svelte/transition/index.mjs");
/* harmony import */ var svelte__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! svelte */ "./node_modules/svelte/index.mjs");
/* harmony import */ var store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! store */ "./src/store/index.js");
/* harmony import */ var _Loader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Loader */ "./src/components/Loader.svelte");
/* src/components/Prompts.svelte generated by Svelte v3.31.2 */







function add_css() {
	var style = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("style");
	style.id = "svelte-1vzjs55-style";
	style.textContent = "div.svelte-1vzjs55{position:absolute;bottom:75px;right:0;padding:12px 18px;font-size:14px;line-height:20px;background:#fff;min-width:65px;min-height:40px;display:flex;align-items:center;justify-content:center;color:#555;border-radius:5px;box-shadow:rgba(0, 0, 0, 0.1) 0px 12px 24px 0px}";
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(document.head, style);
}

// (59:4) {:else}
function create_else_block(ctx) {
	let loader;
	let current;
	loader = new _Loader__WEBPACK_IMPORTED_MODULE_4__.default({ props: { color: "#c0c3c5" } });

	return {
		c() {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_component)(loader.$$.fragment);
		},
		m(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.mount_component)(loader, target, anchor);
			current = true;
		},
		p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		i(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(loader.$$.fragment, local);
			current = true;
		},
		o(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(loader.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.destroy_component)(loader, detaching);
		}
	};
}

// (55:4) {#if currentMessage}
function create_if_block(ctx) {
	let span;
	let t;

	return {
		c() {
			span = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("span");
			t = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.text)(/*currentMessage*/ ctx[0]);
		},
		m(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, span, anchor);
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.append)(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*currentMessage*/ 1) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.set_data)(t, /*currentMessage*/ ctx[0]);
		},
		i: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		o: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.noop,
		d(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(span);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let div_intro;
	let current;
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*currentMessage*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, -1);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.element)("div");
			if_block.c();
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.attr)(div, "class", "with-pointer-arrow svelte-1vzjs55");
		},
		m(target, anchor) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.insert)(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.group_outros)();

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.check_outros)();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block, 1);
				if_block.m(div, null);
			}
		},
		i(local) {
			if (current) return;
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_in)(if_block);

			if (!div_intro) {
				(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.add_render_callback)(() => {
					div_intro = (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.create_in_transition)(div, svelte_transition__WEBPACK_IMPORTED_MODULE_1__.fade, {});
					div_intro.start();
				});
			}

			current = true;
		},
		o(local) {
			(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.transition_out)(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) (0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.detach)(div);
			if_blocks[current_block_type_index].d();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $prompts;
	(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.component_subscribe)($$self, store__WEBPACK_IMPORTED_MODULE_3__.prompts, $$value => $$invalidate(1, $prompts = $$value));
	let currentMessage = null;

	(0,svelte__WEBPACK_IMPORTED_MODULE_2__.onMount)(() => {
		setInterval(
			() => {
				if ($prompts["messages"].length == 0) {
					return;
				}

				
				$$invalidate(0, currentMessage = $prompts["messages"][0]["message"]);

				setTimeout(
					() => {
						if ($prompts["messages"].length !== 1) {
							$$invalidate(0, currentMessage = null);
						}

						store__WEBPACK_IMPORTED_MODULE_3__.prompts.set({
							messages: $prompts["messages"].shift(),
							...$prompts
						});
					},
					2500
				);
			},
			5000
		);
	});

	return [currentMessage];
}

class Prompts extends svelte_internal__WEBPACK_IMPORTED_MODULE_0__.SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-1vzjs55-style")) add_css();
		(0,svelte_internal__WEBPACK_IMPORTED_MODULE_0__.init)(this, options, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal, {});
	}
}


if (false) {}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Prompts);


/***/ }),

/***/ "./node_modules/svelte/easing/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/svelte/easing/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linear": () => /* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.identity,
/* harmony export */   "backIn": () => /* binding */ backIn,
/* harmony export */   "backInOut": () => /* binding */ backInOut,
/* harmony export */   "backOut": () => /* binding */ backOut,
/* harmony export */   "bounceIn": () => /* binding */ bounceIn,
/* harmony export */   "bounceInOut": () => /* binding */ bounceInOut,
/* harmony export */   "bounceOut": () => /* binding */ bounceOut,
/* harmony export */   "circIn": () => /* binding */ circIn,
/* harmony export */   "circInOut": () => /* binding */ circInOut,
/* harmony export */   "circOut": () => /* binding */ circOut,
/* harmony export */   "cubicIn": () => /* binding */ cubicIn,
/* harmony export */   "cubicInOut": () => /* binding */ cubicInOut,
/* harmony export */   "cubicOut": () => /* binding */ cubicOut,
/* harmony export */   "elasticIn": () => /* binding */ elasticIn,
/* harmony export */   "elasticInOut": () => /* binding */ elasticInOut,
/* harmony export */   "elasticOut": () => /* binding */ elasticOut,
/* harmony export */   "expoIn": () => /* binding */ expoIn,
/* harmony export */   "expoInOut": () => /* binding */ expoInOut,
/* harmony export */   "expoOut": () => /* binding */ expoOut,
/* harmony export */   "quadIn": () => /* binding */ quadIn,
/* harmony export */   "quadInOut": () => /* binding */ quadInOut,
/* harmony export */   "quadOut": () => /* binding */ quadOut,
/* harmony export */   "quartIn": () => /* binding */ quartIn,
/* harmony export */   "quartInOut": () => /* binding */ quartInOut,
/* harmony export */   "quartOut": () => /* binding */ quartOut,
/* harmony export */   "quintIn": () => /* binding */ quintIn,
/* harmony export */   "quintInOut": () => /* binding */ quintInOut,
/* harmony export */   "quintOut": () => /* binding */ quintOut,
/* harmony export */   "sineIn": () => /* binding */ sineIn,
/* harmony export */   "sineInOut": () => /* binding */ sineInOut,
/* harmony export */   "sineOut": () => /* binding */ sineOut
/* harmony export */ });
/* harmony import */ var _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/index.mjs */ "./node_modules/svelte/internal/index.mjs");


/*
Adapted from https://github.com/mattdesl
Distributed under MIT License https://github.com/mattdesl/eases/blob/master/LICENSE.md
*/
function backInOut(t) {
    const s = 1.70158 * 1.525;
    if ((t *= 2) < 1)
        return 0.5 * (t * t * ((s + 1) * t - s));
    return 0.5 * ((t -= 2) * t * ((s + 1) * t + s) + 2);
}
function backIn(t) {
    const s = 1.70158;
    return t * t * ((s + 1) * t - s);
}
function backOut(t) {
    const s = 1.70158;
    return --t * t * ((s + 1) * t + s) + 1;
}
function bounceOut(t) {
    const a = 4.0 / 11.0;
    const b = 8.0 / 11.0;
    const c = 9.0 / 10.0;
    const ca = 4356.0 / 361.0;
    const cb = 35442.0 / 1805.0;
    const cc = 16061.0 / 1805.0;
    const t2 = t * t;
    return t < a
        ? 7.5625 * t2
        : t < b
            ? 9.075 * t2 - 9.9 * t + 3.4
            : t < c
                ? ca * t2 - cb * t + cc
                : 10.8 * t * t - 20.52 * t + 10.72;
}
function bounceInOut(t) {
    return t < 0.5
        ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))
        : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;
}
function bounceIn(t) {
    return 1.0 - bounceOut(1.0 - t);
}
function circInOut(t) {
    if ((t *= 2) < 1)
        return -0.5 * (Math.sqrt(1 - t * t) - 1);
    return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
}
function circIn(t) {
    return 1.0 - Math.sqrt(1.0 - t * t);
}
function circOut(t) {
    return Math.sqrt(1 - --t * t);
}
function cubicInOut(t) {
    return t < 0.5 ? 4.0 * t * t * t : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0;
}
function cubicIn(t) {
    return t * t * t;
}
function cubicOut(t) {
    const f = t - 1.0;
    return f * f * f + 1.0;
}
function elasticInOut(t) {
    return t < 0.5
        ? 0.5 *
            Math.sin(((+13.0 * Math.PI) / 2) * 2.0 * t) *
            Math.pow(2.0, 10.0 * (2.0 * t - 1.0))
        : 0.5 *
            Math.sin(((-13.0 * Math.PI) / 2) * (2.0 * t - 1.0 + 1.0)) *
            Math.pow(2.0, -10.0 * (2.0 * t - 1.0)) +
            1.0;
}
function elasticIn(t) {
    return Math.sin((13.0 * t * Math.PI) / 2) * Math.pow(2.0, 10.0 * (t - 1.0));
}
function elasticOut(t) {
    return (Math.sin((-13.0 * (t + 1.0) * Math.PI) / 2) * Math.pow(2.0, -10.0 * t) + 1.0);
}
function expoInOut(t) {
    return t === 0.0 || t === 1.0
        ? t
        : t < 0.5
            ? +0.5 * Math.pow(2.0, 20.0 * t - 10.0)
            : -0.5 * Math.pow(2.0, 10.0 - t * 20.0) + 1.0;
}
function expoIn(t) {
    return t === 0.0 ? t : Math.pow(2.0, 10.0 * (t - 1.0));
}
function expoOut(t) {
    return t === 1.0 ? t : 1.0 - Math.pow(2.0, -10.0 * t);
}
function quadInOut(t) {
    t /= 0.5;
    if (t < 1)
        return 0.5 * t * t;
    t--;
    return -0.5 * (t * (t - 2) - 1);
}
function quadIn(t) {
    return t * t;
}
function quadOut(t) {
    return -t * (t - 2.0);
}
function quartInOut(t) {
    return t < 0.5
        ? +8.0 * Math.pow(t, 4.0)
        : -8.0 * Math.pow(t - 1.0, 4.0) + 1.0;
}
function quartIn(t) {
    return Math.pow(t, 4.0);
}
function quartOut(t) {
    return Math.pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;
}
function quintInOut(t) {
    if ((t *= 2) < 1)
        return 0.5 * t * t * t * t * t;
    return 0.5 * ((t -= 2) * t * t * t * t + 2);
}
function quintIn(t) {
    return t * t * t * t * t;
}
function quintOut(t) {
    return --t * t * t * t * t + 1;
}
function sineInOut(t) {
    return -0.5 * (Math.cos(Math.PI * t) - 1);
}
function sineIn(t) {
    const v = Math.cos(t * Math.PI * 0.5);
    if (Math.abs(v) < 1e-14)
        return 1;
    else
        return 1 - v;
}
function sineOut(t) {
    return Math.sin((t * Math.PI) / 2);
}




/***/ }),

/***/ "./node_modules/svelte/index.mjs":
/*!***************************************!*\
  !*** ./node_modules/svelte/index.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SvelteComponent": () => /* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentDev,
/* harmony export */   "SvelteComponentTyped": () => /* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.SvelteComponentTyped,
/* harmony export */   "afterUpdate": () => /* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.afterUpdate,
/* harmony export */   "beforeUpdate": () => /* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.beforeUpdate,
/* harmony export */   "createEventDispatcher": () => /* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.createEventDispatcher,
/* harmony export */   "getContext": () => /* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.getContext,
/* harmony export */   "hasContext": () => /* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.hasContext,
/* harmony export */   "onDestroy": () => /* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.onDestroy,
/* harmony export */   "onMount": () => /* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.onMount,
/* harmony export */   "setContext": () => /* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.setContext,
/* harmony export */   "tick": () => /* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.tick
/* harmony export */ });
/* harmony import */ var _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/index.mjs */ "./node_modules/svelte/internal/index.mjs");



/***/ }),

/***/ "./node_modules/svelte/internal/index.mjs":
/*!************************************************!*\
  !*** ./node_modules/svelte/internal/index.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HtmlTag": () => /* binding */ HtmlTag,
/* harmony export */   "SvelteComponent": () => /* binding */ SvelteComponent,
/* harmony export */   "SvelteComponentDev": () => /* binding */ SvelteComponentDev,
/* harmony export */   "SvelteComponentTyped": () => /* binding */ SvelteComponentTyped,
/* harmony export */   "SvelteElement": () => /* binding */ SvelteElement,
/* harmony export */   "action_destroyer": () => /* binding */ action_destroyer,
/* harmony export */   "add_attribute": () => /* binding */ add_attribute,
/* harmony export */   "add_classes": () => /* binding */ add_classes,
/* harmony export */   "add_flush_callback": () => /* binding */ add_flush_callback,
/* harmony export */   "add_location": () => /* binding */ add_location,
/* harmony export */   "add_render_callback": () => /* binding */ add_render_callback,
/* harmony export */   "add_resize_listener": () => /* binding */ add_resize_listener,
/* harmony export */   "add_transform": () => /* binding */ add_transform,
/* harmony export */   "afterUpdate": () => /* binding */ afterUpdate,
/* harmony export */   "append": () => /* binding */ append,
/* harmony export */   "append_dev": () => /* binding */ append_dev,
/* harmony export */   "assign": () => /* binding */ assign,
/* harmony export */   "attr": () => /* binding */ attr,
/* harmony export */   "attr_dev": () => /* binding */ attr_dev,
/* harmony export */   "attribute_to_object": () => /* binding */ attribute_to_object,
/* harmony export */   "beforeUpdate": () => /* binding */ beforeUpdate,
/* harmony export */   "bind": () => /* binding */ bind,
/* harmony export */   "binding_callbacks": () => /* binding */ binding_callbacks,
/* harmony export */   "blank_object": () => /* binding */ blank_object,
/* harmony export */   "bubble": () => /* binding */ bubble,
/* harmony export */   "check_outros": () => /* binding */ check_outros,
/* harmony export */   "children": () => /* binding */ children,
/* harmony export */   "claim_component": () => /* binding */ claim_component,
/* harmony export */   "claim_element": () => /* binding */ claim_element,
/* harmony export */   "claim_space": () => /* binding */ claim_space,
/* harmony export */   "claim_text": () => /* binding */ claim_text,
/* harmony export */   "clear_loops": () => /* binding */ clear_loops,
/* harmony export */   "component_subscribe": () => /* binding */ component_subscribe,
/* harmony export */   "compute_rest_props": () => /* binding */ compute_rest_props,
/* harmony export */   "compute_slots": () => /* binding */ compute_slots,
/* harmony export */   "createEventDispatcher": () => /* binding */ createEventDispatcher,
/* harmony export */   "create_animation": () => /* binding */ create_animation,
/* harmony export */   "create_bidirectional_transition": () => /* binding */ create_bidirectional_transition,
/* harmony export */   "create_component": () => /* binding */ create_component,
/* harmony export */   "create_in_transition": () => /* binding */ create_in_transition,
/* harmony export */   "create_out_transition": () => /* binding */ create_out_transition,
/* harmony export */   "create_slot": () => /* binding */ create_slot,
/* harmony export */   "create_ssr_component": () => /* binding */ create_ssr_component,
/* harmony export */   "current_component": () => /* binding */ current_component,
/* harmony export */   "custom_event": () => /* binding */ custom_event,
/* harmony export */   "dataset_dev": () => /* binding */ dataset_dev,
/* harmony export */   "debug": () => /* binding */ debug,
/* harmony export */   "destroy_block": () => /* binding */ destroy_block,
/* harmony export */   "destroy_component": () => /* binding */ destroy_component,
/* harmony export */   "destroy_each": () => /* binding */ destroy_each,
/* harmony export */   "detach": () => /* binding */ detach,
/* harmony export */   "detach_after_dev": () => /* binding */ detach_after_dev,
/* harmony export */   "detach_before_dev": () => /* binding */ detach_before_dev,
/* harmony export */   "detach_between_dev": () => /* binding */ detach_between_dev,
/* harmony export */   "detach_dev": () => /* binding */ detach_dev,
/* harmony export */   "dirty_components": () => /* binding */ dirty_components,
/* harmony export */   "dispatch_dev": () => /* binding */ dispatch_dev,
/* harmony export */   "each": () => /* binding */ each,
/* harmony export */   "element": () => /* binding */ element,
/* harmony export */   "element_is": () => /* binding */ element_is,
/* harmony export */   "empty": () => /* binding */ empty,
/* harmony export */   "escape": () => /* binding */ escape,
/* harmony export */   "escaped": () => /* binding */ escaped,
/* harmony export */   "exclude_internal_props": () => /* binding */ exclude_internal_props,
/* harmony export */   "fix_and_destroy_block": () => /* binding */ fix_and_destroy_block,
/* harmony export */   "fix_and_outro_and_destroy_block": () => /* binding */ fix_and_outro_and_destroy_block,
/* harmony export */   "fix_position": () => /* binding */ fix_position,
/* harmony export */   "flush": () => /* binding */ flush,
/* harmony export */   "getContext": () => /* binding */ getContext,
/* harmony export */   "get_binding_group_value": () => /* binding */ get_binding_group_value,
/* harmony export */   "get_current_component": () => /* binding */ get_current_component,
/* harmony export */   "get_custom_elements_slots": () => /* binding */ get_custom_elements_slots,
/* harmony export */   "get_slot_changes": () => /* binding */ get_slot_changes,
/* harmony export */   "get_slot_context": () => /* binding */ get_slot_context,
/* harmony export */   "get_spread_object": () => /* binding */ get_spread_object,
/* harmony export */   "get_spread_update": () => /* binding */ get_spread_update,
/* harmony export */   "get_store_value": () => /* binding */ get_store_value,
/* harmony export */   "globals": () => /* binding */ globals,
/* harmony export */   "group_outros": () => /* binding */ group_outros,
/* harmony export */   "handle_promise": () => /* binding */ handle_promise,
/* harmony export */   "hasContext": () => /* binding */ hasContext,
/* harmony export */   "has_prop": () => /* binding */ has_prop,
/* harmony export */   "identity": () => /* binding */ identity,
/* harmony export */   "init": () => /* binding */ init,
/* harmony export */   "insert": () => /* binding */ insert,
/* harmony export */   "insert_dev": () => /* binding */ insert_dev,
/* harmony export */   "intros": () => /* binding */ intros,
/* harmony export */   "invalid_attribute_name_character": () => /* binding */ invalid_attribute_name_character,
/* harmony export */   "is_client": () => /* binding */ is_client,
/* harmony export */   "is_crossorigin": () => /* binding */ is_crossorigin,
/* harmony export */   "is_empty": () => /* binding */ is_empty,
/* harmony export */   "is_function": () => /* binding */ is_function,
/* harmony export */   "is_promise": () => /* binding */ is_promise,
/* harmony export */   "listen": () => /* binding */ listen,
/* harmony export */   "listen_dev": () => /* binding */ listen_dev,
/* harmony export */   "loop": () => /* binding */ loop,
/* harmony export */   "loop_guard": () => /* binding */ loop_guard,
/* harmony export */   "missing_component": () => /* binding */ missing_component,
/* harmony export */   "mount_component": () => /* binding */ mount_component,
/* harmony export */   "noop": () => /* binding */ noop,
/* harmony export */   "not_equal": () => /* binding */ not_equal,
/* harmony export */   "now": () => /* binding */ now,
/* harmony export */   "null_to_empty": () => /* binding */ null_to_empty,
/* harmony export */   "object_without_properties": () => /* binding */ object_without_properties,
/* harmony export */   "onDestroy": () => /* binding */ onDestroy,
/* harmony export */   "onMount": () => /* binding */ onMount,
/* harmony export */   "once": () => /* binding */ once,
/* harmony export */   "outro_and_destroy_block": () => /* binding */ outro_and_destroy_block,
/* harmony export */   "prevent_default": () => /* binding */ prevent_default,
/* harmony export */   "prop_dev": () => /* binding */ prop_dev,
/* harmony export */   "query_selector_all": () => /* binding */ query_selector_all,
/* harmony export */   "raf": () => /* binding */ raf,
/* harmony export */   "run": () => /* binding */ run,
/* harmony export */   "run_all": () => /* binding */ run_all,
/* harmony export */   "safe_not_equal": () => /* binding */ safe_not_equal,
/* harmony export */   "schedule_update": () => /* binding */ schedule_update,
/* harmony export */   "select_multiple_value": () => /* binding */ select_multiple_value,
/* harmony export */   "select_option": () => /* binding */ select_option,
/* harmony export */   "select_options": () => /* binding */ select_options,
/* harmony export */   "select_value": () => /* binding */ select_value,
/* harmony export */   "self": () => /* binding */ self,
/* harmony export */   "setContext": () => /* binding */ setContext,
/* harmony export */   "set_attributes": () => /* binding */ set_attributes,
/* harmony export */   "set_current_component": () => /* binding */ set_current_component,
/* harmony export */   "set_custom_element_data": () => /* binding */ set_custom_element_data,
/* harmony export */   "set_data": () => /* binding */ set_data,
/* harmony export */   "set_data_dev": () => /* binding */ set_data_dev,
/* harmony export */   "set_input_type": () => /* binding */ set_input_type,
/* harmony export */   "set_input_value": () => /* binding */ set_input_value,
/* harmony export */   "set_now": () => /* binding */ set_now,
/* harmony export */   "set_raf": () => /* binding */ set_raf,
/* harmony export */   "set_store_value": () => /* binding */ set_store_value,
/* harmony export */   "set_style": () => /* binding */ set_style,
/* harmony export */   "set_svg_attributes": () => /* binding */ set_svg_attributes,
/* harmony export */   "space": () => /* binding */ space,
/* harmony export */   "spread": () => /* binding */ spread,
/* harmony export */   "stop_propagation": () => /* binding */ stop_propagation,
/* harmony export */   "subscribe": () => /* binding */ subscribe,
/* harmony export */   "svg_element": () => /* binding */ svg_element,
/* harmony export */   "text": () => /* binding */ text,
/* harmony export */   "tick": () => /* binding */ tick,
/* harmony export */   "time_ranges_to_array": () => /* binding */ time_ranges_to_array,
/* harmony export */   "to_number": () => /* binding */ to_number,
/* harmony export */   "toggle_class": () => /* binding */ toggle_class,
/* harmony export */   "transition_in": () => /* binding */ transition_in,
/* harmony export */   "transition_out": () => /* binding */ transition_out,
/* harmony export */   "update_keyed_each": () => /* binding */ update_keyed_each,
/* harmony export */   "update_slot": () => /* binding */ update_slot,
/* harmony export */   "update_slot_spread": () => /* binding */ update_slot_spread,
/* harmony export */   "validate_component": () => /* binding */ validate_component,
/* harmony export */   "validate_each_argument": () => /* binding */ validate_each_argument,
/* harmony export */   "validate_each_keys": () => /* binding */ validate_each_keys,
/* harmony export */   "validate_slots": () => /* binding */ validate_slots,
/* harmony export */   "validate_store": () => /* binding */ validate_store,
/* harmony export */   "xlink_attr": () => /* binding */ xlink_attr
/* harmony export */ });
function noop() { }
const identity = x => x;
function assign(tar, src) {
    // @ts-ignore
    for (const k in src)
        tar[k] = src[k];
    return tar;
}
function is_promise(value) {
    return value && typeof value === 'object' && typeof value.then === 'function';
}
function add_location(element, file, line, column, char) {
    element.__svelte_meta = {
        loc: { file, line, column, char }
    };
}
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
function not_equal(a, b) {
    return a != a ? b == b : a !== b;
}
function is_empty(obj) {
    return Object.keys(obj).length === 0;
}
function validate_store(store, name) {
    if (store != null && typeof store.subscribe !== 'function') {
        throw new Error(`'${name}' is not a store with a 'subscribe' method`);
    }
}
function subscribe(store, ...callbacks) {
    if (store == null) {
        return noop;
    }
    const unsub = store.subscribe(...callbacks);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
    let value;
    subscribe(store, _ => value = _)();
    return value;
}
function component_subscribe(component, store, callback) {
    component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
    if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
    }
}
function get_slot_context(definition, ctx, $$scope, fn) {
    return definition[1] && fn
        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
        : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
    if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));
        if ($$scope.dirty === undefined) {
            return lets;
        }
        if (typeof lets === 'object') {
            const merged = [];
            const len = Math.max($$scope.dirty.length, lets.length);
            for (let i = 0; i < len; i += 1) {
                merged[i] = $$scope.dirty[i] | lets[i];
            }
            return merged;
        }
        return $$scope.dirty | lets;
    }
    return $$scope.dirty;
}
function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
    if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
    }
}
function update_slot_spread(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_spread_changes_fn, get_slot_context_fn) {
    const slot_changes = get_slot_spread_changes_fn(dirty) | get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
    if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
    }
}
function exclude_internal_props(props) {
    const result = {};
    for (const k in props)
        if (k[0] !== '$')
            result[k] = props[k];
    return result;
}
function compute_rest_props(props, keys) {
    const rest = {};
    keys = new Set(keys);
    for (const k in props)
        if (!keys.has(k) && k[0] !== '$')
            rest[k] = props[k];
    return rest;
}
function compute_slots(slots) {
    const result = {};
    for (const key in slots) {
        result[key] = true;
    }
    return result;
}
function once(fn) {
    let ran = false;
    return function (...args) {
        if (ran)
            return;
        ran = true;
        fn.call(this, ...args);
    };
}
function null_to_empty(value) {
    return value == null ? '' : value;
}
function set_store_value(store, ret, value = ret) {
    store.set(value);
    return ret;
}
const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
function action_destroyer(action_result) {
    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

const is_client = typeof window !== 'undefined';
let now = is_client
    ? () => window.performance.now()
    : () => Date.now();
let raf = is_client ? cb => requestAnimationFrame(cb) : noop;
// used internally for testing
function set_now(fn) {
    now = fn;
}
function set_raf(fn) {
    raf = fn;
}

const tasks = new Set();
function run_tasks(now) {
    tasks.forEach(task => {
        if (!task.c(now)) {
            tasks.delete(task);
            task.f();
        }
    });
    if (tasks.size !== 0)
        raf(run_tasks);
}
/**
 * For testing purposes only!
 */
function clear_loops() {
    tasks.clear();
}
/**
 * Creates a new task that runs on each raf frame
 * until it returns a falsy value or is aborted
 */
function loop(callback) {
    let task;
    if (tasks.size === 0)
        raf(run_tasks);
    return {
        promise: new Promise(fulfill => {
            tasks.add(task = { c: callback, f: fulfill });
        }),
        abort() {
            tasks.delete(task);
        }
    };
}

function append(target, node) {
    target.appendChild(node);
}
function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}
function detach(node) {
    node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i])
            iterations[i].d(detaching);
    }
}
function element(name) {
    return document.createElement(name);
}
function element_is(name, is) {
    return document.createElement(name, { is });
}
function object_without_properties(obj, exclude) {
    const target = {};
    for (const k in obj) {
        if (has_prop(obj, k)
            // @ts-ignore
            && exclude.indexOf(k) === -1) {
            // @ts-ignore
            target[k] = obj[k];
        }
    }
    return target;
}
function svg_element(name) {
    return document.createElementNS('http://www.w3.org/2000/svg', name);
}
function text(data) {
    return document.createTextNode(data);
}
function space() {
    return text(' ');
}
function empty() {
    return text('');
}
function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
    return function (event) {
        event.preventDefault();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function stop_propagation(fn) {
    return function (event) {
        event.stopPropagation();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function self(fn) {
    return function (event) {
        // @ts-ignore
        if (event.target === this)
            fn.call(this, event);
    };
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function set_attributes(node, attributes) {
    // @ts-ignore
    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
    for (const key in attributes) {
        if (attributes[key] == null) {
            node.removeAttribute(key);
        }
        else if (key === 'style') {
            node.style.cssText = attributes[key];
        }
        else if (key === '__value') {
            node.value = node[key] = attributes[key];
        }
        else if (descriptors[key] && descriptors[key].set) {
            node[key] = attributes[key];
        }
        else {
            attr(node, key, attributes[key]);
        }
    }
}
function set_svg_attributes(node, attributes) {
    for (const key in attributes) {
        attr(node, key, attributes[key]);
    }
}
function set_custom_element_data(node, prop, value) {
    if (prop in node) {
        node[prop] = value;
    }
    else {
        attr(node, prop, value);
    }
}
function xlink_attr(node, attribute, value) {
    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
}
function get_binding_group_value(group, __value, checked) {
    const value = new Set();
    for (let i = 0; i < group.length; i += 1) {
        if (group[i].checked)
            value.add(group[i].__value);
    }
    if (!checked) {
        value.delete(__value);
    }
    return Array.from(value);
}
function to_number(value) {
    return value === '' ? null : +value;
}
function time_ranges_to_array(ranges) {
    const array = [];
    for (let i = 0; i < ranges.length; i += 1) {
        array.push({ start: ranges.start(i), end: ranges.end(i) });
    }
    return array;
}
function children(element) {
    return Array.from(element.childNodes);
}
function claim_element(nodes, name, attributes, svg) {
    for (let i = 0; i < nodes.length; i += 1) {
        const node = nodes[i];
        if (node.nodeName === name) {
            let j = 0;
            const remove = [];
            while (j < node.attributes.length) {
                const attribute = node.attributes[j++];
                if (!attributes[attribute.name]) {
                    remove.push(attribute.name);
                }
            }
            for (let k = 0; k < remove.length; k++) {
                node.removeAttribute(remove[k]);
            }
            return nodes.splice(i, 1)[0];
        }
    }
    return svg ? svg_element(name) : element(name);
}
function claim_text(nodes, data) {
    for (let i = 0; i < nodes.length; i += 1) {
        const node = nodes[i];
        if (node.nodeType === 3) {
            node.data = '' + data;
            return nodes.splice(i, 1)[0];
        }
    }
    return text(data);
}
function claim_space(nodes) {
    return claim_text(nodes, ' ');
}
function set_data(text, data) {
    data = '' + data;
    if (text.wholeText !== data)
        text.data = data;
}
function set_input_value(input, value) {
    input.value = value == null ? '' : value;
}
function set_input_type(input, type) {
    try {
        input.type = type;
    }
    catch (e) {
        // do nothing
    }
}
function set_style(node, key, value, important) {
    node.style.setProperty(key, value, important ? 'important' : '');
}
function select_option(select, value) {
    for (let i = 0; i < select.options.length; i += 1) {
        const option = select.options[i];
        if (option.__value === value) {
            option.selected = true;
            return;
        }
    }
}
function select_options(select, value) {
    for (let i = 0; i < select.options.length; i += 1) {
        const option = select.options[i];
        option.selected = ~value.indexOf(option.__value);
    }
}
function select_value(select) {
    const selected_option = select.querySelector(':checked') || select.options[0];
    return selected_option && selected_option.__value;
}
function select_multiple_value(select) {
    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);
}
// unfortunately this can't be a constant as that wouldn't be tree-shakeable
// so we cache the result instead
let crossorigin;
function is_crossorigin() {
    if (crossorigin === undefined) {
        crossorigin = false;
        try {
            if (typeof window !== 'undefined' && window.parent) {
                void window.parent.document;
            }
        }
        catch (error) {
            crossorigin = true;
        }
    }
    return crossorigin;
}
function add_resize_listener(node, fn) {
    const computed_style = getComputedStyle(node);
    if (computed_style.position === 'static') {
        node.style.position = 'relative';
    }
    const iframe = element('iframe');
    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +
        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
    iframe.setAttribute('aria-hidden', 'true');
    iframe.tabIndex = -1;
    const crossorigin = is_crossorigin();
    let unsubscribe;
    if (crossorigin) {
        iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
        unsubscribe = listen(window, 'message', (event) => {
            if (event.source === iframe.contentWindow)
                fn();
        });
    }
    else {
        iframe.src = 'about:blank';
        iframe.onload = () => {
            unsubscribe = listen(iframe.contentWindow, 'resize', fn);
        };
    }
    append(node, iframe);
    return () => {
        if (crossorigin) {
            unsubscribe();
        }
        else if (unsubscribe && iframe.contentWindow) {
            unsubscribe();
        }
        detach(iframe);
    };
}
function toggle_class(element, name, toggle) {
    element.classList[toggle ? 'add' : 'remove'](name);
}
function custom_event(type, detail) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, false, false, detail);
    return e;
}
function query_selector_all(selector, parent = document.body) {
    return Array.from(parent.querySelectorAll(selector));
}
class HtmlTag {
    constructor(anchor = null) {
        this.a = anchor;
        this.e = this.n = null;
    }
    m(html, target, anchor = null) {
        if (!this.e) {
            this.e = element(target.nodeName);
            this.t = target;
            this.h(html);
        }
        this.i(anchor);
    }
    h(html) {
        this.e.innerHTML = html;
        this.n = Array.from(this.e.childNodes);
    }
    i(anchor) {
        for (let i = 0; i < this.n.length; i += 1) {
            insert(this.t, this.n[i], anchor);
        }
    }
    p(html) {
        this.d();
        this.h(html);
        this.i(this.a);
    }
    d() {
        this.n.forEach(detach);
    }
}
function attribute_to_object(attributes) {
    const result = {};
    for (const attribute of attributes) {
        result[attribute.name] = attribute.value;
    }
    return result;
}
function get_custom_elements_slots(element) {
    const result = {};
    element.childNodes.forEach((node) => {
        result[node.slot || 'default'] = true;
    });
    return result;
}

const active_docs = new Set();
let active = 0;
// https://github.com/darkskyapp/string-hash/blob/master/index.js
function hash(str) {
    let hash = 5381;
    let i = str.length;
    while (i--)
        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
    return hash >>> 0;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
    const step = 16.666 / duration;
    let keyframes = '{\n';
    for (let p = 0; p <= 1; p += step) {
        const t = a + (b - a) * ease(p);
        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
    }
    const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
    const name = `__svelte_${hash(rule)}_${uid}`;
    const doc = node.ownerDocument;
    active_docs.add(doc);
    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);
    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
    if (!current_rules[name]) {
        current_rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
    }
    const animation = node.style.animation || '';
    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
    active += 1;
    return name;
}
function delete_rule(node, name) {
    const previous = (node.style.animation || '').split(', ');
    const next = previous.filter(name
        ? anim => anim.indexOf(name) < 0 // remove specific animation
        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
    );
    const deleted = previous.length - next.length;
    if (deleted) {
        node.style.animation = next.join(', ');
        active -= deleted;
        if (!active)
            clear_rules();
    }
}
function clear_rules() {
    raf(() => {
        if (active)
            return;
        active_docs.forEach(doc => {
            const stylesheet = doc.__svelte_stylesheet;
            let i = stylesheet.cssRules.length;
            while (i--)
                stylesheet.deleteRule(i);
            doc.__svelte_rules = {};
        });
        active_docs.clear();
    });
}

function create_animation(node, from, fn, params) {
    if (!from)
        return noop;
    const to = node.getBoundingClientRect();
    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
        return noop;
    const { delay = 0, duration = 300, easing = identity, 
    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
    start: start_time = now() + delay, 
    // @ts-ignore todo:
    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);
    let running = true;
    let started = false;
    let name;
    function start() {
        if (css) {
            name = create_rule(node, 0, 1, duration, delay, easing, css);
        }
        if (!delay) {
            started = true;
        }
    }
    function stop() {
        if (css)
            delete_rule(node, name);
        running = false;
    }
    loop(now => {
        if (!started && now >= start_time) {
            started = true;
        }
        if (started && now >= end) {
            tick(1, 0);
            stop();
        }
        if (!running) {
            return false;
        }
        if (started) {
            const p = now - start_time;
            const t = 0 + 1 * easing(p / duration);
            tick(t, 1 - t);
        }
        return true;
    });
    start();
    tick(0, 1);
    return stop;
}
function fix_position(node) {
    const style = getComputedStyle(node);
    if (style.position !== 'absolute' && style.position !== 'fixed') {
        const { width, height } = style;
        const a = node.getBoundingClientRect();
        node.style.position = 'absolute';
        node.style.width = width;
        node.style.height = height;
        add_transform(node, a);
    }
}
function add_transform(node, a) {
    const b = node.getBoundingClientRect();
    if (a.left !== b.left || a.top !== b.top) {
        const style = getComputedStyle(node);
        const transform = style.transform === 'none' ? '' : style.transform;
        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
    }
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error('Function called outside component initialization');
    return current_component;
}
function beforeUpdate(fn) {
    get_current_component().$$.before_update.push(fn);
}
function onMount(fn) {
    get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
    get_current_component().$$.after_update.push(fn);
}
function onDestroy(fn) {
    get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
    const component = get_current_component();
    return (type, detail) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
            // TODO are there situations where events could be dispatched
            // in a server (non-DOM) environment?
            const event = custom_event(type, detail);
            callbacks.slice().forEach(fn => {
                fn.call(component, event);
            });
        }
    };
}
function setContext(key, context) {
    get_current_component().$$.context.set(key, context);
}
function getContext(key) {
    return get_current_component().$$.context.get(key);
}
function hasContext(key) {
    return get_current_component().$$.context.has(key);
}
// TODO figure out if we still want to support
// shorthand events, or if we want to implement
// a real bubbling mechanism
function bubble(component, event) {
    const callbacks = component.$$.callbacks[event.type];
    if (callbacks) {
        callbacks.slice().forEach(fn => fn(event));
    }
}

const dirty_components = [];
const intros = { enabled: false };
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function tick() {
    schedule_update();
    return resolved_promise;
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
function add_flush_callback(fn) {
    flush_callbacks.push(fn);
}
let flushing = false;
const seen_callbacks = new Set();
function flush() {
    if (flushing)
        return;
    flushing = true;
    do {
        // first, call beforeUpdate functions
        // and update components
        for (let i = 0; i < dirty_components.length; i += 1) {
            const component = dirty_components[i];
            set_current_component(component);
            update(component.$$);
        }
        set_current_component(null);
        dirty_components.length = 0;
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
                callback();
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
    flushing = false;
    seen_callbacks.clear();
}
function update($$) {
    if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
    }
}

let promise;
function wait() {
    if (!promise) {
        promise = Promise.resolve();
        promise.then(() => {
            promise = null;
        });
    }
    return promise;
}
function dispatch(node, direction, kind) {
    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
}
const outroing = new Set();
let outros;
function group_outros() {
    outros = {
        r: 0,
        c: [],
        p: outros // parent group
    };
}
function check_outros() {
    if (!outros.r) {
        run_all(outros.c);
    }
    outros = outros.p;
}
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}
function transition_out(block, local, detach, callback) {
    if (block && block.o) {
        if (outroing.has(block))
            return;
        outroing.add(block);
        outros.c.push(() => {
            outroing.delete(block);
            if (callback) {
                if (detach)
                    block.d(1);
                callback();
            }
        });
        block.o(local);
    }
}
const null_transition = { duration: 0 };
function create_in_transition(node, fn, params) {
    let config = fn(node, params);
    let running = false;
    let animation_name;
    let task;
    let uid = 0;
    function cleanup() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function go() {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        if (css)
            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
        tick(0, 1);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        if (task)
            task.abort();
        running = true;
        add_render_callback(() => dispatch(node, true, 'start'));
        task = loop(now => {
            if (running) {
                if (now >= end_time) {
                    tick(1, 0);
                    dispatch(node, true, 'end');
                    cleanup();
                    return running = false;
                }
                if (now >= start_time) {
                    const t = easing((now - start_time) / duration);
                    tick(t, 1 - t);
                }
            }
            return running;
        });
    }
    let started = false;
    return {
        start() {
            if (started)
                return;
            delete_rule(node);
            if (is_function(config)) {
                config = config();
                wait().then(go);
            }
            else {
                go();
            }
        },
        invalidate() {
            started = false;
        },
        end() {
            if (running) {
                cleanup();
                running = false;
            }
        }
    };
}
function create_out_transition(node, fn, params) {
    let config = fn(node, params);
    let running = true;
    let animation_name;
    const group = outros;
    group.r += 1;
    function go() {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        if (css)
            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        add_render_callback(() => dispatch(node, false, 'start'));
        loop(now => {
            if (running) {
                if (now >= end_time) {
                    tick(0, 1);
                    dispatch(node, false, 'end');
                    if (!--group.r) {
                        // this will result in `end()` being called,
                        // so we don't need to clean up here
                        run_all(group.c);
                    }
                    return false;
                }
                if (now >= start_time) {
                    const t = easing((now - start_time) / duration);
                    tick(1 - t, t);
                }
            }
            return running;
        });
    }
    if (is_function(config)) {
        wait().then(() => {
            // @ts-ignore
            config = config();
            go();
        });
    }
    else {
        go();
    }
    return {
        end(reset) {
            if (reset && config.tick) {
                config.tick(1, 0);
            }
            if (running) {
                if (animation_name)
                    delete_rule(node, animation_name);
                running = false;
            }
        }
    };
}
function create_bidirectional_transition(node, fn, params, intro) {
    let config = fn(node, params);
    let t = intro ? 0 : 1;
    let running_program = null;
    let pending_program = null;
    let animation_name = null;
    function clear_animation() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function init(program, duration) {
        const d = program.b - t;
        duration *= Math.abs(d);
        return {
            a: t,
            b: program.b,
            d,
            duration,
            start: program.start,
            end: program.start + duration,
            group: program.group
        };
    }
    function go(b) {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        const program = {
            start: now() + delay,
            b
        };
        if (!b) {
            // @ts-ignore todo: improve typings
            program.group = outros;
            outros.r += 1;
        }
        if (running_program || pending_program) {
            pending_program = program;
        }
        else {
            // if this is an intro, and there's a delay, we need to do
            // an initial tick and/or apply CSS animation immediately
            if (css) {
                clear_animation();
                animation_name = create_rule(node, t, b, duration, delay, easing, css);
            }
            if (b)
                tick(0, 1);
            running_program = init(program, duration);
            add_render_callback(() => dispatch(node, b, 'start'));
            loop(now => {
                if (pending_program && now > pending_program.start) {
                    running_program = init(pending_program, duration);
                    pending_program = null;
                    dispatch(node, running_program.b, 'start');
                    if (css) {
                        clear_animation();
                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                    }
                }
                if (running_program) {
                    if (now >= running_program.end) {
                        tick(t = running_program.b, 1 - t);
                        dispatch(node, running_program.b, 'end');
                        if (!pending_program) {
                            // we're done
                            if (running_program.b) {
                                // intro  we can tidy up immediately
                                clear_animation();
                            }
                            else {
                                // outro  needs to be coordinated
                                if (!--running_program.group.r)
                                    run_all(running_program.group.c);
                            }
                        }
                        running_program = null;
                    }
                    else if (now >= running_program.start) {
                        const p = now - running_program.start;
                        t = running_program.a + running_program.d * easing(p / running_program.duration);
                        tick(t, 1 - t);
                    }
                }
                return !!(running_program || pending_program);
            });
        }
    }
    return {
        run(b) {
            if (is_function(config)) {
                wait().then(() => {
                    // @ts-ignore
                    config = config();
                    go(b);
                });
            }
            else {
                go(b);
            }
        },
        end() {
            clear_animation();
            running_program = pending_program = null;
        }
    };
}

function handle_promise(promise, info) {
    const token = info.token = {};
    function update(type, index, key, value) {
        if (info.token !== token)
            return;
        info.resolved = value;
        let child_ctx = info.ctx;
        if (key !== undefined) {
            child_ctx = child_ctx.slice();
            child_ctx[key] = value;
        }
        const block = type && (info.current = type)(child_ctx);
        let needs_flush = false;
        if (info.block) {
            if (info.blocks) {
                info.blocks.forEach((block, i) => {
                    if (i !== index && block) {
                        group_outros();
                        transition_out(block, 1, 1, () => {
                            if (info.blocks[i] === block) {
                                info.blocks[i] = null;
                            }
                        });
                        check_outros();
                    }
                });
            }
            else {
                info.block.d(1);
            }
            block.c();
            transition_in(block, 1);
            block.m(info.mount(), info.anchor);
            needs_flush = true;
        }
        info.block = block;
        if (info.blocks)
            info.blocks[index] = block;
        if (needs_flush) {
            flush();
        }
    }
    if (is_promise(promise)) {
        const current_component = get_current_component();
        promise.then(value => {
            set_current_component(current_component);
            update(info.then, 1, info.value, value);
            set_current_component(null);
        }, error => {
            set_current_component(current_component);
            update(info.catch, 2, info.error, error);
            set_current_component(null);
            if (!info.hasCatch) {
                throw error;
            }
        });
        // if we previously had a then/catch block, destroy it
        if (info.current !== info.pending) {
            update(info.pending, 0);
            return true;
        }
    }
    else {
        if (info.current !== info.then) {
            update(info.then, 1, info.value, promise);
            return true;
        }
        info.resolved = promise;
    }
}

const globals = (typeof window !== 'undefined'
    ? window
    : typeof globalThis !== 'undefined'
        ? globalThis
        : global);

function destroy_block(block, lookup) {
    block.d(1);
    lookup.delete(block.key);
}
function outro_and_destroy_block(block, lookup) {
    transition_out(block, 1, 1, () => {
        lookup.delete(block.key);
    });
}
function fix_and_destroy_block(block, lookup) {
    block.f();
    destroy_block(block, lookup);
}
function fix_and_outro_and_destroy_block(block, lookup) {
    block.f();
    outro_and_destroy_block(block, lookup);
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
    let o = old_blocks.length;
    let n = list.length;
    let i = o;
    const old_indexes = {};
    while (i--)
        old_indexes[old_blocks[i].key] = i;
    const new_blocks = [];
    const new_lookup = new Map();
    const deltas = new Map();
    i = n;
    while (i--) {
        const child_ctx = get_context(ctx, list, i);
        const key = get_key(child_ctx);
        let block = lookup.get(key);
        if (!block) {
            block = create_each_block(key, child_ctx);
            block.c();
        }
        else if (dynamic) {
            block.p(child_ctx, dirty);
        }
        new_lookup.set(key, new_blocks[i] = block);
        if (key in old_indexes)
            deltas.set(key, Math.abs(i - old_indexes[key]));
    }
    const will_move = new Set();
    const did_move = new Set();
    function insert(block) {
        transition_in(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n--;
    }
    while (o && n) {
        const new_block = new_blocks[n - 1];
        const old_block = old_blocks[o - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;
        if (new_block === old_block) {
            // do nothing
            next = new_block.first;
            o--;
            n--;
        }
        else if (!new_lookup.has(old_key)) {
            // remove old block
            destroy(old_block, lookup);
            o--;
        }
        else if (!lookup.has(new_key) || will_move.has(new_key)) {
            insert(new_block);
        }
        else if (did_move.has(old_key)) {
            o--;
        }
        else if (deltas.get(new_key) > deltas.get(old_key)) {
            did_move.add(new_key);
            insert(new_block);
        }
        else {
            will_move.add(old_key);
            o--;
        }
    }
    while (o--) {
        const old_block = old_blocks[o];
        if (!new_lookup.has(old_block.key))
            destroy(old_block, lookup);
    }
    while (n)
        insert(new_blocks[n - 1]);
    return new_blocks;
}
function validate_each_keys(ctx, list, get_context, get_key) {
    const keys = new Set();
    for (let i = 0; i < list.length; i++) {
        const key = get_key(get_context(ctx, list, i));
        if (keys.has(key)) {
            throw new Error('Cannot have duplicate keys in a keyed each');
        }
        keys.add(key);
    }
}

function get_spread_update(levels, updates) {
    const update = {};
    const to_null_out = {};
    const accounted_for = { $$scope: 1 };
    let i = levels.length;
    while (i--) {
        const o = levels[i];
        const n = updates[i];
        if (n) {
            for (const key in o) {
                if (!(key in n))
                    to_null_out[key] = 1;
            }
            for (const key in n) {
                if (!accounted_for[key]) {
                    update[key] = n[key];
                    accounted_for[key] = 1;
                }
            }
            levels[i] = n;
        }
        else {
            for (const key in o) {
                accounted_for[key] = 1;
            }
        }
    }
    for (const key in to_null_out) {
        if (!(key in update))
            update[key] = undefined;
    }
    return update;
}
function get_spread_object(spread_props) {
    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
}

// source: https://html.spec.whatwg.org/multipage/indices.html
const boolean_attributes = new Set([
    'allowfullscreen',
    'allowpaymentrequest',
    'async',
    'autofocus',
    'autoplay',
    'checked',
    'controls',
    'default',
    'defer',
    'disabled',
    'formnovalidate',
    'hidden',
    'ismap',
    'loop',
    'multiple',
    'muted',
    'nomodule',
    'novalidate',
    'open',
    'playsinline',
    'readonly',
    'required',
    'reversed',
    'selected'
]);

const invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
// https://infra.spec.whatwg.org/#noncharacter
function spread(args, classes_to_add) {
    const attributes = Object.assign({}, ...args);
    if (classes_to_add) {
        if (attributes.class == null) {
            attributes.class = classes_to_add;
        }
        else {
            attributes.class += ' ' + classes_to_add;
        }
    }
    let str = '';
    Object.keys(attributes).forEach(name => {
        if (invalid_attribute_name_character.test(name))
            return;
        const value = attributes[name];
        if (value === true)
            str += ' ' + name;
        else if (boolean_attributes.has(name.toLowerCase())) {
            if (value)
                str += ' ' + name;
        }
        else if (value != null) {
            str += ` ${name}="${String(value).replace(/"/g, '&#34;').replace(/'/g, '&#39;')}"`;
        }
    });
    return str;
}
const escaped = {
    '"': '&quot;',
    "'": '&#39;',
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;'
};
function escape(html) {
    return String(html).replace(/["'&<>]/g, match => escaped[match]);
}
function each(items, fn) {
    let str = '';
    for (let i = 0; i < items.length; i += 1) {
        str += fn(items[i], i);
    }
    return str;
}
const missing_component = {
    $$render: () => ''
};
function validate_component(component, name) {
    if (!component || !component.$$render) {
        if (name === 'svelte:component')
            name += ' this={...}';
        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
    }
    return component;
}
function debug(file, line, column, values) {
    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console
    console.log(values); // eslint-disable-line no-console
    return '';
}
let on_destroy;
function create_ssr_component(fn) {
    function $$render(result, props, bindings, slots) {
        const parent_component = current_component;
        const $$ = {
            on_destroy,
            context: new Map(parent_component ? parent_component.$$.context : []),
            // these will be immediately discarded
            on_mount: [],
            before_update: [],
            after_update: [],
            callbacks: blank_object()
        };
        set_current_component({ $$ });
        const html = fn(result, props, bindings, slots);
        set_current_component(parent_component);
        return html;
    }
    return {
        render: (props = {}, options = {}) => {
            on_destroy = [];
            const result = { title: '', head: '', css: new Set() };
            const html = $$render(result, props, {}, options);
            run_all(on_destroy);
            return {
                html,
                css: {
                    code: Array.from(result.css).map(css => css.code).join('\n'),
                    map: null // TODO
                },
                head: result.title + result.head
            };
        },
        $$render
    };
}
function add_attribute(name, value, boolean) {
    if (value == null || (boolean && !value))
        return '';
    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `"${value}"`}`}`;
}
function add_classes(classes) {
    return classes ? ` class="${classes}"` : '';
}

function bind(component, name, callback) {
    const index = component.$$.props[name];
    if (index !== undefined) {
        component.$$.bound[index] = callback;
        callback(component.$$.ctx[index]);
    }
}
function create_component(block) {
    block && block.c();
}
function claim_component(block, parent_nodes) {
    block && block.l(parent_nodes);
}
function mount_component(component, target, anchor) {
    const { fragment, on_mount, on_destroy, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    // onMount happens before the initial afterUpdate
    add_render_callback(() => {
        const new_on_destroy = on_mount.map(run).filter(is_function);
        if (on_destroy) {
            on_destroy.push(...new_on_destroy);
        }
        else {
            // Edge case - component was destroyed immediately,
            // most likely as a result of a binding initialising
            run_all(new_on_destroy);
        }
        component.$$.on_mount = [];
    });
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
    }
}
function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
    }
    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
}
function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const prop_values = options.props || {};
    const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        before_update: [],
        after_update: [],
        context: new Map(parent_component ? parent_component.$$.context : []),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false
    };
    let ready = false;
    $$.ctx = instance
        ? instance(component, prop_values, (i, ret, ...rest) => {
            const value = rest.length ? rest[0] : ret;
            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                if (!$$.skip_bound && $$.bound[i])
                    $$.bound[i](value);
                if (ready)
                    make_dirty(component, i);
            }
            return ret;
        })
        : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            const nodes = children(options.target);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(nodes);
            nodes.forEach(detach);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor);
        flush();
    }
    set_current_component(parent_component);
}
let SvelteElement;
if (typeof HTMLElement === 'function') {
    SvelteElement = class extends HTMLElement {
        constructor() {
            super();
            this.attachShadow({ mode: 'open' });
        }
        connectedCallback() {
            // @ts-ignore todo: improve typings
            for (const key in this.$$.slotted) {
                // @ts-ignore todo: improve typings
                this.appendChild(this.$$.slotted[key]);
            }
        }
        attributeChangedCallback(attr, _oldValue, newValue) {
            this[attr] = newValue;
        }
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            // TODO should this delegate to addEventListener?
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    };
}
/**
 * Base class for Svelte components. Used when dev=false.
 */
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set($$props) {
        if (this.$$set && !is_empty($$props)) {
            this.$$.skip_bound = true;
            this.$$set($$props);
            this.$$.skip_bound = false;
        }
    }
}

function dispatch_dev(type, detail) {
    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.31.2' }, detail)));
}
function append_dev(target, node) {
    dispatch_dev('SvelteDOMInsert', { target, node });
    append(target, node);
}
function insert_dev(target, node, anchor) {
    dispatch_dev('SvelteDOMInsert', { target, node, anchor });
    insert(target, node, anchor);
}
function detach_dev(node) {
    dispatch_dev('SvelteDOMRemove', { node });
    detach(node);
}
function detach_between_dev(before, after) {
    while (before.nextSibling && before.nextSibling !== after) {
        detach_dev(before.nextSibling);
    }
}
function detach_before_dev(after) {
    while (after.previousSibling) {
        detach_dev(after.previousSibling);
    }
}
function detach_after_dev(before) {
    while (before.nextSibling) {
        detach_dev(before.nextSibling);
    }
}
function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
    if (has_prevent_default)
        modifiers.push('preventDefault');
    if (has_stop_propagation)
        modifiers.push('stopPropagation');
    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
    const dispose = listen(node, event, handler, options);
    return () => {
        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
        dispose();
    };
}
function attr_dev(node, attribute, value) {
    attr(node, attribute, value);
    if (value == null)
        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
    else
        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
}
function prop_dev(node, property, value) {
    node[property] = value;
    dispatch_dev('SvelteDOMSetProperty', { node, property, value });
}
function dataset_dev(node, property, value) {
    node.dataset[property] = value;
    dispatch_dev('SvelteDOMSetDataset', { node, property, value });
}
function set_data_dev(text, data) {
    data = '' + data;
    if (text.wholeText === data)
        return;
    dispatch_dev('SvelteDOMSetData', { node: text, data });
    text.data = data;
}
function validate_each_argument(arg) {
    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
        let msg = '{#each} only iterates over array-like objects.';
        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
            msg += ' You can use a spread to convert this iterable into an array.';
        }
        throw new Error(msg);
    }
}
function validate_slots(name, slot, keys) {
    for (const slot_key of Object.keys(slot)) {
        if (!~keys.indexOf(slot_key)) {
            console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
        }
    }
}
/**
 * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
 */
class SvelteComponentDev extends SvelteComponent {
    constructor(options) {
        if (!options || (!options.target && !options.$$inline)) {
            throw new Error("'target' is a required option");
        }
        super();
    }
    $destroy() {
        super.$destroy();
        this.$destroy = () => {
            console.warn('Component was already destroyed'); // eslint-disable-line no-console
        };
    }
    $capture_state() { }
    $inject_state() { }
}
/**
 * Base class to create strongly typed Svelte components.
 * This only exists for typing purposes and should be used in `.d.ts` files.
 *
 * ### Example:
 *
 * You have component library on npm called `component-library`, from which
 * you export a component called `MyComponent`. For Svelte+TypeScript users,
 * you want to provide typings. Therefore you create a `index.d.ts`:
 * ```ts
 * import { SvelteComponentTyped } from "svelte";
 * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}
 * ```
 * Typing this makes it possible for IDEs like VS Code with the Svelte extension
 * to provide intellisense and to use the component like this in a Svelte file
 * with TypeScript:
 * ```svelte
 * <script lang="ts">
 * 	import { MyComponent } from "component-library";
 * </script>
 * <MyComponent foo={'bar'} />
 * ```
 *
 * #### Why not make this part of `SvelteComponent(Dev)`?
 * Because
 * ```ts
 * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}
 * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;
 * ```
 * will throw a type error, so we need to seperate the more strictly typed class.
 */
class SvelteComponentTyped extends SvelteComponentDev {
    constructor(options) {
        super(options);
    }
}
function loop_guard(timeout) {
    const start = Date.now();
    return () => {
        if (Date.now() - start > timeout) {
            throw new Error('Infinite loop detected');
        }
    };
}




/***/ }),

/***/ "./node_modules/svelte/store/index.mjs":
/*!*********************************************!*\
  !*** ./node_modules/svelte/store/index.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "get": () => /* reexport safe */ _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.get_store_value,
/* harmony export */   "derived": () => /* binding */ derived,
/* harmony export */   "readable": () => /* binding */ readable,
/* harmony export */   "writable": () => /* binding */ writable
/* harmony export */ });
/* harmony import */ var _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/index.mjs */ "./node_modules/svelte/internal/index.mjs");



const subscriber_queue = [];
/**
 * Creates a `Readable` store that allows reading by subscription.
 * @param value initial value
 * @param {StartStopNotifier}start start and stop notifications for subscriptions
 */
function readable(value, start) {
    return {
        subscribe: writable(value, start).subscribe
    };
}
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
 */
function writable(value, start = _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop) {
    let stop;
    const subscribers = [];
    function set(new_value) {
        if ((0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.safe_not_equal)(value, new_value)) {
            value = new_value;
            if (stop) { // store is ready
                const run_queue = !subscriber_queue.length;
                for (let i = 0; i < subscribers.length; i += 1) {
                    const s = subscribers[i];
                    s[1]();
                    subscriber_queue.push(s, value);
                }
                if (run_queue) {
                    for (let i = 0; i < subscriber_queue.length; i += 2) {
                        subscriber_queue[i][0](subscriber_queue[i + 1]);
                    }
                    subscriber_queue.length = 0;
                }
            }
        }
    }
    function update(fn) {
        set(fn(value));
    }
    function subscribe(run, invalidate = _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop) {
        const subscriber = [run, invalidate];
        subscribers.push(subscriber);
        if (subscribers.length === 1) {
            stop = start(set) || _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop;
        }
        run(value);
        return () => {
            const index = subscribers.indexOf(subscriber);
            if (index !== -1) {
                subscribers.splice(index, 1);
            }
            if (subscribers.length === 0) {
                stop();
                stop = null;
            }
        };
    }
    return { set, update, subscribe };
}
function derived(stores, fn, initial_value) {
    const single = !Array.isArray(stores);
    const stores_array = single
        ? [stores]
        : stores;
    const auto = fn.length < 2;
    return readable(initial_value, (set) => {
        let inited = false;
        const values = [];
        let pending = 0;
        let cleanup = _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop;
        const sync = () => {
            if (pending) {
                return;
            }
            cleanup();
            const result = fn(single ? values[0] : values, set);
            if (auto) {
                set(result);
            }
            else {
                cleanup = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.is_function)(result) ? result : _internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.noop;
            }
        };
        const unsubscribers = stores_array.map((store, i) => (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.subscribe)(store, (value) => {
            values[i] = value;
            pending &= ~(1 << i);
            if (inited) {
                sync();
            }
        }, () => {
            pending |= (1 << i);
        }));
        inited = true;
        sync();
        return function stop() {
            (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_0__.run_all)(unsubscribers);
            cleanup();
        };
    });
}




/***/ }),

/***/ "./node_modules/svelte/transition/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/svelte/transition/index.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "blur": () => /* binding */ blur,
/* harmony export */   "crossfade": () => /* binding */ crossfade,
/* harmony export */   "draw": () => /* binding */ draw,
/* harmony export */   "fade": () => /* binding */ fade,
/* harmony export */   "fly": () => /* binding */ fly,
/* harmony export */   "scale": () => /* binding */ scale,
/* harmony export */   "slide": () => /* binding */ slide
/* harmony export */ });
/* harmony import */ var _easing_index_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../easing/index.mjs */ "./node_modules/svelte/easing/index.mjs");
/* harmony import */ var _internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal/index.mjs */ "./node_modules/svelte/internal/index.mjs");



/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function blur(node, { delay = 0, duration = 400, easing = _easing_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cubicInOut, amount = 5, opacity = 0 }) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const f = style.filter === 'none' ? '' : style.filter;
    const od = target_opacity * (1 - opacity);
    return {
        delay,
        duration,
        easing,
        css: (_t, u) => `opacity: ${target_opacity - (od * u)}; filter: ${f} blur(${u * amount}px);`
    };
}
function fade(node, { delay = 0, duration = 400, easing = _easing_index_mjs__WEBPACK_IMPORTED_MODULE_0__.linear }) {
    const o = +getComputedStyle(node).opacity;
    return {
        delay,
        duration,
        easing,
        css: t => `opacity: ${t * o}`
    };
}
function fly(node, { delay = 0, duration = 400, easing = _easing_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cubicOut, x = 0, y = 0, opacity = 0 }) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const transform = style.transform === 'none' ? '' : style.transform;
    const od = target_opacity * (1 - opacity);
    return {
        delay,
        duration,
        easing,
        css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
    };
}
function slide(node, { delay = 0, duration = 400, easing = _easing_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cubicOut }) {
    const style = getComputedStyle(node);
    const opacity = +style.opacity;
    const height = parseFloat(style.height);
    const padding_top = parseFloat(style.paddingTop);
    const padding_bottom = parseFloat(style.paddingBottom);
    const margin_top = parseFloat(style.marginTop);
    const margin_bottom = parseFloat(style.marginBottom);
    const border_top_width = parseFloat(style.borderTopWidth);
    const border_bottom_width = parseFloat(style.borderBottomWidth);
    return {
        delay,
        duration,
        easing,
        css: t => 'overflow: hidden;' +
            `opacity: ${Math.min(t * 20, 1) * opacity};` +
            `height: ${t * height}px;` +
            `padding-top: ${t * padding_top}px;` +
            `padding-bottom: ${t * padding_bottom}px;` +
            `margin-top: ${t * margin_top}px;` +
            `margin-bottom: ${t * margin_bottom}px;` +
            `border-top-width: ${t * border_top_width}px;` +
            `border-bottom-width: ${t * border_bottom_width}px;`
    };
}
function scale(node, { delay = 0, duration = 400, easing = _easing_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cubicOut, start = 0, opacity = 0 }) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const transform = style.transform === 'none' ? '' : style.transform;
    const sd = 1 - start;
    const od = target_opacity * (1 - opacity);
    return {
        delay,
        duration,
        easing,
        css: (_t, u) => `
			transform: ${transform} scale(${1 - (sd * u)});
			opacity: ${target_opacity - (od * u)}
		`
    };
}
function draw(node, { delay = 0, speed, duration, easing = _easing_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cubicInOut }) {
    const len = node.getTotalLength();
    if (duration === undefined) {
        if (speed === undefined) {
            duration = 800;
        }
        else {
            duration = len / speed;
        }
    }
    else if (typeof duration === 'function') {
        duration = duration(len);
    }
    return {
        delay,
        duration,
        easing,
        css: (t, u) => `stroke-dasharray: ${t * len} ${u * len}`
    };
}
function crossfade(_a) {
    var { fallback } = _a, defaults = __rest(_a, ["fallback"]);
    const to_receive = new Map();
    const to_send = new Map();
    function crossfade(from, node, params) {
        const { delay = 0, duration = d => Math.sqrt(d) * 30, easing = _easing_index_mjs__WEBPACK_IMPORTED_MODULE_0__.cubicOut } = (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)((0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.assign)({}, defaults), params);
        const to = node.getBoundingClientRect();
        const dx = from.left - to.left;
        const dy = from.top - to.top;
        const dw = from.width / to.width;
        const dh = from.height / to.height;
        const d = Math.sqrt(dx * dx + dy * dy);
        const style = getComputedStyle(node);
        const transform = style.transform === 'none' ? '' : style.transform;
        const opacity = +style.opacity;
        return {
            delay,
            duration: (0,_internal_index_mjs__WEBPACK_IMPORTED_MODULE_1__.is_function)(duration) ? duration(d) : duration,
            easing,
            css: (t, u) => `
				opacity: ${t * opacity};
				transform-origin: top left;
				transform: ${transform} translate(${u * dx}px,${u * dy}px) scale(${t + (1 - t) * dw}, ${t + (1 - t) * dh});
			`
        };
    }
    function transition(items, counterparts, intro) {
        return (node, params) => {
            items.set(params.key, {
                rect: node.getBoundingClientRect()
            });
            return () => {
                if (counterparts.has(params.key)) {
                    const { rect } = counterparts.get(params.key);
                    counterparts.delete(params.key);
                    return crossfade(rect, node, params);
                }
                // if the node is disappearing altogether
                // (i.e. wasn't claimed by the other list)
                // then we need to supply an outro
                items.delete(params.key);
                return fallback && fallback(node, params, intro);
            };
        };
    }
    return [
        transition(to_send, to_receive, false),
        transition(to_receive, to_send, true)
    ];
}




/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _components_App__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/App */ "./src/components/App.svelte");


const app = new _components_App__WEBPACK_IMPORTED_MODULE_0__.default({
	target: document.getElementById('instant-support')
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (app);


/***/ }),

/***/ "./src/store/index.js":
/*!****************************!*\
  !*** ./src/store/index.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "button": () => /* binding */ button,
/* harmony export */   "menu": () => /* binding */ menu,
/* harmony export */   "prompts": () => /* binding */ prompts,
/* harmony export */   "showButton": () => /* binding */ showButton,
/* harmony export */   "showMenu": () => /* binding */ showMenu,
/* harmony export */   "showPrompts": () => /* binding */ showPrompts,
/* harmony export */   "showIntegration": () => /* binding */ showIntegration,
/* harmony export */   "integration": () => /* binding */ integration
/* harmony export */ });
/* harmony import */ var svelte_store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! svelte/store */ "./node_modules/svelte/store/index.mjs");


const button = (0,svelte_store__WEBPACK_IMPORTED_MODULE_0__.writable)(instant_support.button);
const menu = (0,svelte_store__WEBPACK_IMPORTED_MODULE_0__.writable)(instant_support.menu);
const prompts = (0,svelte_store__WEBPACK_IMPORTED_MODULE_0__.writable)(instant_support.prompts);

const showButton = (0,svelte_store__WEBPACK_IMPORTED_MODULE_0__.writable)(false)
const showMenu = (0,svelte_store__WEBPACK_IMPORTED_MODULE_0__.writable)(false)
const showPrompts = (0,svelte_store__WEBPACK_IMPORTED_MODULE_0__.writable)(false)

const showIntegration = (0,svelte_store__WEBPACK_IMPORTED_MODULE_0__.writable)(false)
const integration = (0,svelte_store__WEBPACK_IMPORTED_MODULE_0__.writable)(null)


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./src/main.js");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;
//# sourceMappingURL=bundle.js.map